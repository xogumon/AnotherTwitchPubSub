{"version":3,"file":"bundle.min.js","mappings":"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","sources":["webpack://anothertwitchpubsub/webpack/bootstrap","webpack://anothertwitchpubsub/webpack/runtime/global","webpack://anothertwitchpubsub/./src/modules/EventEmitter.ts","webpack://anothertwitchpubsub/./src/modules/WebSocket.ts","webpack://anothertwitchpubsub/./src/modules/Options.ts","webpack://anothertwitchpubsub/./src/modules/Utils.ts","webpack://anothertwitchpubsub/./src/index.ts","webpack://anothertwitchpubsub/./src/modules/Client.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","/**\r\n * EventEmitter\r\n */\r\nexport default class EventEmitter {\r\n  private events: { [event: string]: Function[] } = {};\r\n  /**\r\n   * Emit an event\r\n   * @param event Event to emit\r\n   * @param data Data to emit\r\n   * @returns Returns a promise with a number of emitted events\r\n   * @example\r\n   * emitter.emit('event', 'data');\r\n   */\r\n  public async emit(event: string | string[], ...data: any[]) {\r\n    let count: number = 0;\r\n    await new Promise(async (resolve) => {\r\n      if (Array.isArray(event)) {\r\n        await Promise.all(\r\n          event.map(async (e: string) => {\r\n            await this.emit(e, ...data).then(() => {\r\n              count++;\r\n            });\r\n          })\r\n        );\r\n      } else if (event === \"*\") {\r\n        for (const key in this.events) {\r\n          if (this.events.hasOwnProperty(key)) {\r\n            this.events[key].forEach((listener) => {\r\n              count++;\r\n              listener(...data);\r\n            });\r\n          }\r\n        }\r\n      } else if (typeof event === \"string\" && event.includes(\"*\")) {\r\n        const [eventName, ...rest] = event.split(\"*\");\r\n        for (const key in this.events) {\r\n          if (this.events.hasOwnProperty(key) && key.startsWith(eventName)) {\r\n            this.events[key].forEach((listener) => {\r\n              count++;\r\n              listener(...data);\r\n            });\r\n          }\r\n        }\r\n      } else if (\r\n        typeof event === \"string\" &&\r\n        event.toLowerCase() in this.events\r\n      ) {\r\n        this.events[event.toLowerCase()].forEach((listener) => {\r\n          count++;\r\n          listener(...data);\r\n        });\r\n      }\r\n      resolve(count);\r\n    });\r\n    return `Emitted ${count} events to listeners`;\r\n  }\r\n  /**\r\n   * Listen to an event\r\n   * @param event Event to listen to\r\n   * @param callback Callback to execute when the event is emitted\r\n   * @example\r\n   * emitter.on('event', (data) => {\r\n   *   console.log(data);\r\n   * });\r\n   * emitter.emit('event', 'data'); // Outputs 'data'\r\n   */\r\n  public on(event: string | string[], callback: Function) {\r\n    if (Array.isArray(event)) {\r\n      event.map((e: string) => {\r\n        this.on(e, callback);\r\n      });\r\n    } else if (typeof event === \"string\") {\r\n      if (!this.events[event]) {\r\n        this.events[event] = [];\r\n      }\r\n      this.events[event].push(callback);\r\n    }\r\n  }\r\n  /**\r\n   * Remove an event listener\r\n   * @param event Event to remove listener from\r\n   * @param callback Callback to remove\r\n   * @example\r\n   * const callback = (data) => {\r\n   *   console.log(data);\r\n   * };\r\n   * emitter.on('event', callback);\r\n   * emitter.emit('event', 'data'); // Outputs 'data'\r\n   * emitter.removeListener('event', callback);\r\n   * emitter.emit('event', 'data'); // Doesn't output 'data'\r\n   */\r\n  public removeListener(event: string, callback: Function) {\r\n    if (this.events[event]) {\r\n      this.events[event] = this.events[event].filter(\r\n        (cb: Function) => cb !== callback\r\n      );\r\n    }\r\n  }\r\n  /**\r\n   * Remove all event listeners for an event\r\n   * @param event Event to remove listeners from\r\n   * @example\r\n   * emitter.on('event', (data) => {\r\n   *   console.log(data);\r\n   * });\r\n   * emitter.emit('event', 'data'); // Outputs 'data'\r\n   * emitter.removeAllListeners('event');\r\n   * emitter.emit('event', 'data'); // Doesn't output 'data'\r\n   */\r\n  public removeAllListeners(event: string) {\r\n    if (this.events[event]) {\r\n      this.events[event] = [];\r\n    }\r\n  }\r\n  /**\r\n   * Once an event is emitted, remove all event listeners for that event\r\n   * @param event Event to remove listeners from\r\n   * @example\r\n   * emitter.once('event', (data) => {\r\n   *   console.log(data);\r\n   * });\r\n   * emitter.emit('event', 'data'); // Outputs 'data'\r\n   * emitter.emit('event', 'data'); // Doesn't output 'data'\r\n   */\r\n  public once(event: string, callback: Function) {\r\n    this.on(event, (data: any) => {\r\n      this.removeListener(event, callback);\r\n      callback(data);\r\n    });\r\n  }\r\n}\r\n","let ws:\r\n  | typeof WebSocket\r\n  | typeof global.WebSocket\r\n  | typeof window.WebSocket\r\n  | typeof self.WebSocket =\r\n  WebSocket || global.WebSocket || window.WebSocket || self.WebSocket;\r\n\r\nif (!ws) {\r\n  throw new Error(\"WebSocket is not supported by this browser.\");\r\n}\r\n\r\nexport default ws;\r\n","/**\r\n * Options\r\n */\r\nexport interface thisOptions {\r\n  /**\r\n   * Options\r\n   */\r\n  accessToken: string;\r\n  topics: string[];\r\n  autoConnect: boolean;\r\n  autoReconnect: boolean;\r\n  reconnectInterval: number;\r\n  reconnectAttempts: number;\r\n}\r\nclass AnotherTwitchPubSubOptions {\r\n  /**\r\n   * Store the options.\r\n   */\r\n  private options: thisOptions = {\r\n    accessToken: \"\",\r\n    topics: [],\r\n    autoConnect: true,\r\n    autoReconnect: true,\r\n    reconnectInterval: 10000,\r\n    reconnectAttempts: 10,\r\n  };\r\n\r\n  /**\r\n   * Set the options.\r\n   */\r\n  public set(options: thisOptions) {\r\n    this.options = Object.assign({}, this.options, options);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Get the options.\r\n   */\r\n  public get() {\r\n    return this.options;\r\n  }\r\n\r\n  /**\r\n   * Set the access token.\r\n   * @param accessToken The access token to use.\r\n   * @returns This instance.\r\n   */\r\n  public setToken(accessToken: string) {\r\n    this.options.accessToken = accessToken;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the topics to subscribe to.\r\n   * @param topics The topics to subscribe to.\r\n   * @returns This instance.\r\n   */\r\n  public setTopics(topics: string[]) {\r\n    this.options.topics = topics;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Find a topic in the topics.\r\n   * @param topic The topic to find.\r\n   */\r\n  public findTopic(topic: string) {\r\n    return this.options.topics.indexOf(topic) > -1;\r\n  }\r\n\r\n  /**\r\n   * Add a topic to the topics.\r\n   * @param topic The topic to add.\r\n   */\r\n  public addTopic(topic: string) {\r\n    if (!this.options.topics.includes(topic)) {\r\n      this.options.topics.push(topic);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove a topic from the topics.\r\n   * @param topic The topic to remove.\r\n   */\r\n  public removeTopic(topic: string) {\r\n    const index = this.options.topics.indexOf(topic);\r\n    if (index > -1) {\r\n      this.options.topics.splice(index, 1);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add topics to the topics.\r\n   * @param topics The topics to add.\r\n   */\r\n  public addTopics(topics: string[]) {\r\n    if (!Array.isArray(topics)) {\r\n      this.addTopic(topics);\r\n    } else {\r\n      for (const topic of topics) {\r\n        this.addTopic(topic);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove topics from the topics.\r\n   * @param topics The topics to remove.\r\n   */\r\n  public removeTopics(topics: string[]) {\r\n    if (!Array.isArray(topics)) {\r\n      this.removeTopic(topics);\r\n    } else {\r\n      for (const topic of topics) {\r\n        this.removeTopic(topic);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n}\r\nexport default new AnotherTwitchPubSubOptions();\r\n","import Options from \"./Options\";\r\nexport default {\r\n  /**\r\n   * isEmpty\r\n   * @param obj Object to check\r\n   * @returns True if the object is empty, false otherwise\r\n   */\r\n  isEmpty(obj: any) {\r\n    if (\r\n      obj === \"\" ||\r\n      obj === 0 ||\r\n      obj === false ||\r\n      obj === null ||\r\n      obj === undefined\r\n    ) {\r\n      return true;\r\n    }\r\n    if (Array.isArray(obj)) {\r\n      return obj.length === 0;\r\n    } else if (typeof obj === \"object\") {\r\n      return Object.keys(obj).length === 0;\r\n    }\r\n    return false;\r\n  },\r\n  /**\r\n   * Lowercase a array items\r\n   * @param arr Array to lowercase\r\n   * @returns Array with all items lowercased\r\n   * @example\r\n   * const arr = ['THIS', 'IS', 'A', 'TEST'];\r\n   * const lowercased = arrayLowerCase(arr);\r\n   * console.log(lowercased); // ['this', 'is', 'a', 'test']\r\n   */\r\n  arrayLowerCase(arr: any[]) {\r\n    return arr.map((item) => item.toLowerCase());\r\n  },\r\n  /**\r\n   * Repeat a method a number of times\r\n   * @param fn Method to repeat\r\n   * @param times Number of times to repeat\r\n   * @returns Array with the repeated method\r\n   * @example\r\n   * const repeat = repeat(() => 1, 5);\r\n   * console.log(repeat); // [1, 1, 1, 1, 1]\r\n   */\r\n  repeat(fn: Function, times: number) {\r\n    let result = [];\r\n    for (let i = 0; i < times; i++) {\r\n      result.push(fn());\r\n    }\r\n    return result;\r\n  },\r\n  /**\r\n   * Generate a random nonce\r\n   * @returns Random nonce\r\n   */\r\n  nonce() {\r\n    const random = () => Math.random().toString(36).substring(2, 15);\r\n    return this.repeat(random, 2).join(\"\");\r\n  },\r\n  /**\r\n   * Convert a string to a camelCase string\r\n   */\r\n  toCamelCase(str: string) {\r\n    return str.replace(/\\s(.)/g, ($1) => $1.toUpperCase());\r\n  },\r\n  /**\r\n   * Slugify a string\r\n   * @param str String to slugify\r\n   * @param sep Separator to use\r\n   * @returns Slugified string\r\n   * @example\r\n   * const slug = slug(\"This is a string\", \"-\");\r\n   * console.log(slug); // this-is-a-string\r\n   */\r\n  slug(str: string, sep: string = \"-\") {\r\n    if (typeof str !== \"string\") return \"\";\r\n    if (typeof sep !== \"string\") sep = \"-\";\r\n    str = str.toLowerCase().replace(/[^a-z0-9]/g, sep); // replace all non-alphanumeric characters with the separator\r\n    if (sep.length > 0) {\r\n      str = str\r\n        .replace(new RegExp(`${sep}{2,}`, \"g\"), sep) // replace multiple separators with a single one\r\n        .replace(new RegExp(`^${sep}|${sep}$`, \"g\"), \"\"); // remove leading and trailing separators\r\n    }\r\n    return str; // return the slug\r\n  },\r\n  /**\r\n   * Slugify to camelCase string\r\n   * @param str String to slugify\r\n   * @returns Slugified string in camelCase without separators\r\n   * @example\r\n   * const slug = slugToCamelCase(\"This is a string\");\r\n   * console.log(slug); // thisIsAString\r\n   */\r\n  slugToCamelCase(str: string) {\r\n    return this.slug(str)\r\n      .replace(/-([a-z])/g, ($1: string) => $1.toUpperCase())\r\n      .replace(/-/g, \"\");\r\n  },\r\n  /**\r\n   * Remove duplicate values from an array\r\n   * @param arr Array to remove duplicates from\r\n   * @returns Array with no duplicates\r\n   * @example\r\n   * const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n   * const unique = removeDuplicates(arr);\r\n   * console.log(unique); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n   */\r\n  removeDuplicates(arr: any[]) {\r\n    return arr.filter((item, index) => arr.indexOf(item) === index);\r\n  },\r\n  /**\r\n   * Validate a token with Twitch's API\r\n   * @returns Validation result from Twitch's API\r\n   */\r\n  async validateToken() {\r\n    const res = await fetch(\"https://id.twitch.tv/oauth2/validate\", {\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: `OAuth ${Options.get().accessToken}`,\r\n      },\r\n    });\r\n    return await res.json();\r\n  },\r\n  /**\r\n   * Get user data from Twitch's API\r\n   * @param user User to get the ID of\r\n   * @returns Array containing the user's ID\r\n   * @example\r\n   * const user = \"twitch\";\r\n   * const token = \"oauth:token\";\r\n   * const id = await getUserId(user, token);\r\n   * console.log(id); // [1234]\r\n   */\r\n  async getUserId(user: any) {\r\n    let find: string;\r\n    if (typeof user === \"string\") {\r\n      find = `login=${user}`;\r\n    } else if (typeof user === \"object\") {\r\n      find = user.map((name: string) => `login=${name}`).join(\"&\");\r\n    } else {\r\n      throw new Error(\"User must be a string or an array of strings\");\r\n    }\r\n    try {\r\n      const api = await this.validateToken();\r\n      if (api.client_id) {\r\n        if (api.login === user.toLowerCase()) {\r\n          return [api.user_id];\r\n        } else {\r\n          const res = await fetch(`https://api.twitch.tv/helix/users?${find}`, {\r\n            headers: {\r\n              \"Client-ID\": api.client_id,\r\n              Authorization: `Bearer ${Options.get().accessToken}`,\r\n            },\r\n          });\r\n          const data = await res.json();\r\n          if (data.data.length > 0) {\r\n            return data.data.map((user: any) => user.id);\r\n          } else {\r\n            throw new Error(\"User not found\");\r\n          }\r\n        }\r\n      } else {\r\n        throw new Error(\"Invalid token\");\r\n      }\r\n    } catch (err) {\r\n      return console.log(err);\r\n    }\r\n  },\r\n  /**\r\n   * Returns if string is a number or not\r\n   */\r\n  isNumber(str: string) {\r\n    return !isNaN(Number(str));\r\n  },\r\n\r\n  /**\r\n   * Check if an topic is valid\r\n   * @param topic Topic to check\r\n   * @returns True if topic is valid, false otherwise\r\n   * @example\r\n   * console.log(isValidTopic('channel-bits-events-v2')); // true\r\n   * console.log(isValidTopic('channel-bits-events-v3')); // false\r\n   */\r\n  isValidTopic(topic: string) {\r\n    try {\r\n      if (typeof topic !== \"string\") {\r\n        throw new Error(\"Invalid topic\");\r\n      }\r\n      if (topic.length > 100) {\r\n        throw new Error(\"Topic is too long\");\r\n      }\r\n      if (topic.length < 5) {\r\n        throw new Error(\"Topic is too short\");\r\n      }\r\n      if (topic.includes(\" \")) {\r\n        throw new Error(\"Topic cannot contain spaces\");\r\n      }\r\n      if (!this.getTopicsFormat(topic)) {\r\n        throw new Error(\"Topic is invalid\");\r\n      }\r\n      return true;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  },\r\n  /**\r\n   * Returns a correct format of a topic\r\n   * @param topicName Topic to format\r\n   * @returns Formatted topic\r\n   */\r\n  getTopicsFormat(topicName: string) {\r\n    topicName = this.slugToCamelCase(topicName);\r\n    const validTopics = {\r\n      channelBitsEventsV1: \"channel-bits-events-v2.$arg1$\",\r\n      channelBitsEventsV2: \"channel-bits-events-v2.$arg1$\",\r\n      channelBitsBadgeUnlocks: \"channel-bits-badge-unlocks.$arg1$\",\r\n      channelPointsChannelV1: \"channel-points-channel-v1.$arg1$\",\r\n      channelSubscribeEventsV1: \"channel-subscribe-events-v2.$arg1$\",\r\n      chatModeratorActions: \"chat_moderator_actions.$arg1$.$arg2$\",\r\n      automodQueue: \"automod-queue.$arg1$.$arg2$\",\r\n      userModerationNotifications:\r\n        \"user-moderation-notifications.$arg1$.$arg2$\",\r\n      whispers: \"whispers.$arg1$\",\r\n    };\r\n    return validTopics[topicName];\r\n  },\r\n  /**\r\n   * Filter an array of topics\r\n   * @param topics Array of topics to filter\r\n   * @returns Array of valid topics\r\n   */\r\n  filterTopics(topics: string[]) {\r\n    topics = this.arrayLowerCase(topics);\r\n    topics = this.removeDuplicates(topics);\r\n    return topics.filter((topic: string) => this.isValidTopic(topic));\r\n  },\r\n  /**\r\n   * Parse a topic to get the arguments\r\n   * @param topic Topic to parse\r\n   * @returns Array of arguments\r\n   */\r\n  async parseTopic(topic: string) {\r\n    let [topicName, arg1, arg2] = topic.split(\".\");\r\n    const topicFormat = this.getTopicsFormat(topicName);\r\n    if (topicFormat) {\r\n      if (arg1 || arg2) {\r\n        if (!this.isNumber(arg1) && !this.isNumber(arg2)) {\r\n          [arg1, arg2] = await this.getUserId([arg1, arg2]);\r\n        } else if (!this.isNumber(arg1)) {\r\n          [arg1] = await this.getUserId(arg1);\r\n        } else if (!this.isNumber(arg2)) {\r\n          [arg2] = await this.getUserId(arg2);\r\n        }\r\n      } else {\r\n        const validade = await this.validateToken();\r\n        if (validade.login) {\r\n          arg1 = validade.user_id;\r\n          arg2 = validade.user_id;\r\n        } else {\r\n          throw new Error(\"Invalid token\");\r\n        }\r\n      }\r\n      if (this.isNumber(arg1) && this.isNumber(arg2)) {\r\n        return topicFormat.replace(\"$arg1$\", arg1).replace(\"$arg2$\", arg2);\r\n      } else {\r\n        return topicFormat.replace(\"$arg1$\", arg1);\r\n      }\r\n    }\r\n    return null;\r\n  },\r\n  /**\r\n   * Parse array of topics to get the arguments\r\n   * @param topics Array of topics to parse\r\n   * @returns Array of arguments\r\n   */\r\n  async parseTopics(topics: string[]) {\r\n    this.filterTopics(topics);\r\n    return await Promise.all(\r\n      topics.map((topic: string) => this.parseTopic(topic))\r\n    );\r\n  },\r\n};\r\n","import Client from \"./modules/Client\";\r\nimport EventEmitter from \"./modules/EventEmitter\";\r\nimport Options from \"./modules/Options\";\r\nimport Utils from \"./modules/Utils\";\r\nconst PubSub = new Client();\r\nconst Emitter = new EventEmitter();\r\n/**\r\n * @class AnotherTwitchPubSub\r\n * @author Ronis Xogum <ronis@xogum.net> (https://github.com/xogumon)\r\n * @version 1.0.0\r\n * @description A simple Twitch PubSub client\r\n * @license MIT\r\n * @param {string} accessToken - The authentication token of the channel you want to subscribe to.\r\n * @param {boolean} autoConnect - Whether or not to automatically connect to Twitch PubSub.\r\n * @param {boolean} autoReconnect - Whether or not to automatically reconnect to Twitch PubSub if the connection is lost.\r\n * @param {number} reconnectAttempts - The number of reconnect attempts to make before giving up.\r\n * @param {number} reconnectInterval - The time in milliseconds between reconnect attempts.\r\n * @param {string[]} topics - The topics you want to subscribe to.\r\n * @example\r\n * new TwitchPubSub({\r\n *  accessToken: 'authToken',\r\n *  topics: ['topic1', 'topic2']\r\n * }).on('message', (topic, message) => {\r\n *  console.log(topic, message);\r\n * });\r\n */\r\nclass AnotherTwitchPubSub {\r\n  private __latency: number = 0;\r\n  private __timestamp: number = 0;\r\n  constructor(options: any) {\r\n    Options.set(options);\r\n    if (Options.get().autoConnect) this.__connect();\r\n    PubSub.on(\"connected\", () => this.__onConnection());\r\n    PubSub.on(\"disconnected\", (event: any) => this.__onDisconnection(event));\r\n    PubSub.on(\"error\", (event: any) => this.__onEventError(event));\r\n    PubSub.on(\"message\", (event: any) => this.__onEventMessage(event));\r\n    PubSub.on(\"ping\", (event: any) => this.__onPingSent(event));\r\n    PubSub.on(\"pong\", (event: any) => this.__onPongReceived(event));\r\n    PubSub.on(\"raw\", (event: any) => this.__onRawMessage(event));\r\n    PubSub.on(\"response\", (event: any) => this.__onResponseMessage(event));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Connect to the pubsub websocket\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.__connect().then(() => {\r\n   *  console.log(\"Connected!\");\r\n   * });\r\n   */\r\n  private async __connect() {\r\n    await new Promise((resolve, reject) => {\r\n      if (PubSub.state() === \"DISCONNECTED\") {\r\n        PubSub.connect()\r\n          .then(() => {\r\n            resolve(null);\r\n          })\r\n          .catch((e: any) => {\r\n            reject(e);\r\n          });\r\n      } else {\r\n        resolve(null);\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Disconnect from the pubsub websocket\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.__disconnect().then(() => {\r\n   *  console.log(\"Disconnected!\");\r\n   * });\r\n   */\r\n  private async __disconnect() {\r\n    await new Promise((resolve) => {\r\n      if (PubSub.state() === \"CONNECTED\") {\r\n        PubSub.disconnect();\r\n      } else if (PubSub.state() === \"DISCONNECTED\") {\r\n        resolve(null);\r\n      }\r\n      PubSub.on(\"disconnected\", () => {\r\n        resolve(null);\r\n      });\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /** Reconnect to the pubsub websocket\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.reconnect().then(() => {\r\n   *  console.log(\"Reconnected!\");\r\n   * });\r\n   */\r\n  private async __reconnect(attempts: number = 0) {\r\n    await new Promise((resolve, reject) => {\r\n      function connect() {\r\n        setTimeout(() => {\r\n          PubSub.connect()\r\n            .then(() => {\r\n              resolve(null);\r\n            })\r\n            .catch((e: any) => {\r\n              setTimeout(() => {\r\n                this.__reconnect(attempts + 1);\r\n              }, Options.get().reconnectInterval);\r\n              reject(e);\r\n            });\r\n        }, Options.get().reconnectInterval);\r\n      }\r\n      if (PubSub.state() === \"CONNECTING\") {\r\n        reject(new Error(\"Already reconnecting\"));\r\n      }\r\n      if (attempts >= Options.get().reconnectAttempts) {\r\n        reject(new Error(\"Reconnect attempts exceeded\"));\r\n      }\r\n      if (PubSub.state() === \"DISCONNECTED\") {\r\n        connect();\r\n      }\r\n      if (PubSub.state() === \"CONNECTED\") {\r\n        if (attempts === 0) {\r\n          PubSub.disconnect();\r\n          PubSub.on(\"disconnected\", () => {\r\n            connect();\r\n          });\r\n        }\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Send a message to the pubsub websocket\r\n   * @param data Data to send\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.__send({\r\n   *  type: \"PING\"\r\n   * }).then(() => {\r\n   *  console.log(\"Message sent!\");\r\n   * });\r\n   */\r\n  private async __send(data: object) {\r\n    if (PubSub.state() === \"CONNECTED\") {\r\n      return await PubSub.send(data);\r\n    } else {\r\n      throw new Error(\"Not connected\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribe to a topic or topics (if an array is provided)\r\n   * @param topics Topics to subscribe to\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.__subscribe(\"test\").then(() => {\r\n   *  console.log(\"Subscribed!\");\r\n   * });\r\n   */\r\n  private async __subscribe(topics: string[]) {\r\n    await new Promise(async (resolve, reject) => {\r\n      if (PubSub.state() !== \"CONNECTED\") {\r\n        reject(new Error(\"Not connected\"));\r\n      } else {\r\n        if (!Array.isArray(topics)) {\r\n          topics = [topics];\r\n        }\r\n        topics = await Utils.parseTopics(topics);\r\n        if (topics.length > 0) {\r\n          const data = {\r\n            type: \"LISTEN\",\r\n            nonce: Utils.nonce(),\r\n            data: {\r\n              topics,\r\n              auth_token: Options.get().accessToken,\r\n            },\r\n          };\r\n          this.__send(data)\r\n            .then((response) => {\r\n              if (\r\n                response.type === \"RESPONSE\" &&\r\n                Utils.isEmpty(response.error)\r\n              ) {\r\n                this.__emit(\"subscribed\", topics);\r\n                resolve(Options.addTopics(topics));\r\n              } else {\r\n                reject(new Error(\"Subscription failed\"));\r\n              }\r\n            })\r\n            .catch((e) => {\r\n              reject(e);\r\n            });\r\n        } else {\r\n          resolve(null);\r\n        }\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from a topic or topics (if an array is provided)\r\n   * @param topics Topics to unsubscribe from (if omitted, all topics are unsubscribed)\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.__unsubscribe(\"test\").then(() => {\r\n   *  console.log(\"Unsubscribed!\");\r\n   * });\r\n   */\r\n  private async __unsubscribe(topics: string[]) {\r\n    await new Promise(async (resolve, reject) => {\r\n      if (PubSub.state() !== \"CONNECTED\") {\r\n        reject(new Error(\"Not connected\"));\r\n      } else {\r\n        if (!Array.isArray(topics)) {\r\n          topics = [topics];\r\n        }\r\n        topics = await Utils.parseTopics(topics ?? Options.get().topics);\r\n        if (topics.length > 0) {\r\n          const data = {\r\n            type: \"UNLISTEN\",\r\n            nonce: Utils.nonce(),\r\n            data: {\r\n              topics,\r\n              auth_token: Options.get().accessToken,\r\n            },\r\n          };\r\n          this.__send(data)\r\n            .then((response) => {\r\n              if (\r\n                response.type === \"RESPONSE\" &&\r\n                Utils.isEmpty(response.error)\r\n              ) {\r\n                this.__emit(\"unsubscribed\", topics);\r\n                resolve(Options.removeTopics(topics));\r\n              } else {\r\n                reject(new Error(\"Unsubscription failed\"));\r\n              }\r\n            })\r\n            .catch((e) => {\r\n              reject(e);\r\n            });\r\n        } else {\r\n          resolve(null);\r\n        }\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Open event handler (Client)\r\n   */\r\n  private __onConnection() {\r\n    if (Options.get().topics) this.__subscribe(Options.get().topics);\r\n    this.__emit(\"connected\");\r\n  }\r\n\r\n  /**\r\n   * Close event handler (Client)\r\n   * @param event Event\r\n   */\r\n  private __onDisconnection(event: CloseEvent) {\r\n    if (!event.wasClean && Options.get().autoReconnect) {\r\n      this.__reconnect();\r\n    }\r\n    this.__emit(\"disconnected\", event);\r\n  }\r\n\r\n  /**\r\n   * Message event handler (Client)\r\n   * @param event The event that was received\r\n   */\r\n  private __onRawMessage(event: MessageEvent) {\r\n    const eventData = JSON.parse(event.data);\r\n    const { type, data } = eventData;\r\n    switch (type) {\r\n      case \"LISTEN\":\r\n      case \"UNLISTEN\":\r\n        this.__emit(type, data);\r\n      case \"RECONNECT\":\r\n      case \"DISCONNECT\":\r\n        this.__emit(type);\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Error event handler (Client)\r\n   * @param event The event that was received\r\n   */\r\n  private __onEventError(event: ErrorEvent) {\r\n    this.__emitErrorEvent(event.error);\r\n  }\r\n\r\n  /**\r\n   * Error event handler\r\n   * @param event The error event\r\n   */\r\n  private __emitErrorEvent(event: any) {\r\n    if (event instanceof Error) {\r\n      this.__emit(\"error\", event.message);\r\n    } else {\r\n      this.__emit(\"error\", event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Message event handler\r\n   * @param data The event that was received\r\n   */\r\n  private __onEventMessage(data: any) {\r\n    // Emit raw message as message event\r\n    this.__emit(\"message\", data);\r\n    // Topic and messages (message is a data object from raw message)\r\n    const { topic, message } = data.data;\r\n    // Emit message event for topic\r\n    this.__emit(topic, JSON.parse(message));\r\n    // messageType is the type of topic and messageData is the data of the message\r\n    const { type: messageType, data: messageData } = JSON.parse(message);\r\n    const topicEvents = [\r\n      \"channel-points-channel\",\r\n      \"channel-bits-events\",\r\n      \"channel-bits-badge-unlocks\",\r\n      \"channel-subscribe-events\",\r\n      \"whispers\",\r\n    ];\r\n    // Find the event name for the topic\r\n    const eventName = topicEvents.find((event) => topic.includes(event));\r\n    // Handle events for each topic\r\n    switch (eventName) {\r\n      case \"channel-points-channel\":\r\n        // Channel points events\r\n        this.__onChannelPointsEvent({\r\n          type: messageType,\r\n          data: messageData,\r\n        });\r\n        break;\r\n      case \"channel-bits-events\":\r\n      case \"channel-bits-badge-unlocks\":\r\n        // Channel bits events and badge unlocks\r\n        this.__onBitsEvent({\r\n          type: eventName,\r\n          data: messageData,\r\n        });\r\n        break;\r\n      case \"channel-subscribe-events\":\r\n        // Channel subscription events\r\n        this.__onSubEvent(messageData);\r\n        break;\r\n      case \"whispers\":\r\n        // Whisper events\r\n        this.__onWhisperEvent({\r\n          type: messageData.type,\r\n          data: data.data_object,\r\n        });\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Response event handler\r\n   * @param data The response data\r\n   */\r\n  private __onResponseMessage(data: any) {\r\n    let errorMessage: string;\r\n    if (data?.error) {\r\n      switch (data.error) {\r\n        case \"ERR_BADAUTH\":\r\n          errorMessage = \"Invalid authentication token\";\r\n          break;\r\n        case \"ERR_BADTOPIC\":\r\n          errorMessage = \"Invalid topic\";\r\n          break;\r\n        case \"ERR_BADMESSAGE\":\r\n          errorMessage = \"Invalid message\";\r\n          break;\r\n        case \"ERR_SERVER\":\r\n          errorMessage = \"Server error\";\r\n          break;\r\n        default:\r\n          errorMessage = \"Unknown error\" + data.error;\r\n          break;\r\n      }\r\n      this.__emitErrorEvent(errorMessage);\r\n    } else {\r\n      if (data) this.__emit(\"response\", data);\r\n    }\r\n  }\r\n\r\n  private __onPingSent(timestamp: number) {\r\n    this.__timestamp = timestamp;\r\n    this.__emit(\"ping\");\r\n  }\r\n\r\n  /**\r\n   * Pong event handler\r\n   */\r\n  private __onPongReceived(timestamp: number) {\r\n    this.__latency = timestamp - this.__timestamp;\r\n    this.__emit(\"pong\", this.__latency);\r\n    if (this.__latency > 1e4) {\r\n      if (Options.get().autoReconnect) {\r\n        this.__reconnect();\r\n      } else {\r\n        // if latency is greater than 10 seconds\r\n        this.__emit(\"warning\", {\r\n          message: \"Latency is very high\",\r\n          latency: this.__latency,\r\n        });\r\n      }\r\n    } else if (this.__latency > 1e3) {\r\n      // if latency is greater than 1 second\r\n      this.__emit(\"warning\", {\r\n        message: \"Latency is high\",\r\n        latency: this.__latency,\r\n      });\r\n    } else if (this.__latency > 1e2) {\r\n      // if latency is greater than 100 milliseconds\r\n      this.__emit(\"warning\", {\r\n        message: \"Latency is medium\",\r\n        latency: this.__latency,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bits event handler\r\n   * @param data The data object\r\n   */\r\n  private __onBitsEvent({ type, data }: { type: string; data: any }) {\r\n    switch (type) {\r\n      case \"channel-bits-events\":\r\n        this.__emit(\"bits\", data);\r\n        break;\r\n      case \"channel-bits-badge-unlocks\":\r\n        this.__emit(\"bitsbadge\", data);\r\n        break;\r\n      default:\r\n        this.__emitErrorEvent(new Error(`Unknown message type: ${type}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscription event handler\r\n   * (sub, resub, subgift, anonsubgift)\r\n   * @param data The data object\r\n   */\r\n  private __onSubEvent(data: any) {\r\n    this.__emit(data.context, {\r\n      userId: data.user_id || null, // user id of the user who subscribed\r\n      userName: data.user_name || null, // user name of the user who subscribed\r\n      displayName: data.display_name || null, // display name of the user who subscribed\r\n      channelId: data.channel_id, // channel id of the channel the subscription was made in\r\n      channelName: data.channel_name, // channel name of the channel the subscription was made in\r\n      time: data.time, // time the subscription was made\r\n      subPlan: data.sub_plan, // subscription plan the user subscribed to\r\n      subPlanName: data.sub_plan_name, // subscription plan name the user subscribed to\r\n      isGift: data.is_gift || false, // whether the subscription was a gift subscription\r\n      months: data.months || null, // number of months the subscription was for\r\n      cumulativeMonths: data.cumulative_months || null, // number of cumulative months the user has subscribed for\r\n      streakMonths: data.streak_months || null, // number of months the user has been subscribed for in a row\r\n      subMessage: data.sub_message || null, // subscription message the user sent\r\n      recipientId: data.recipient_id || null, // user id of the user the subscription was gifted to\r\n      recipientUserName: data.recipient_user_name || null, // user name of the user the subscription was gifted to\r\n      recipientDisplayName: data.recipient_display_name || null, // display name of the user the subscription was gifted to\r\n      multiMonthDuration: data.multi_month_duration || null, // number of months the subscription was for\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Whisper event handler\r\n   * @param data The data object\r\n   */\r\n  private __onWhisperEvent(data: any) {\r\n    this.__emit(data.type, data.data);\r\n  }\r\n\r\n  /**\r\n   * Channel points event handler\r\n   * @param data The data object\r\n   */\r\n  private __onChannelPointsEvent({ type, data }: { type: string; data: any }) {\r\n    switch (type) {\r\n      case \"reward-redeemed\":\r\n        this.__emit(\"reward\", data.redemption);\r\n        this.__emit(type, data.redemption);\r\n        break;\r\n      default:\r\n        this.__emit(type, data);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Emit an event\r\n   * @param eventName Event to emit\r\n   * @param args Data to emit\r\n   * @returns This instance\r\n   */\r\n  private __emit(eventName: string, ...args: any[]) {\r\n    eventName = Utils.slug(eventName);\r\n    Emitter.emit(eventName, ...args);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add a listener to an event\r\n   * @param eventName Event to listen to\r\n   * @param callback Callback to call when the event is emitted\r\n   * @returns This instance\r\n   * @example\r\n   * pubsub.on(\"message\", (data) => {\r\n   *  console.log(data);\r\n   * });\r\n   */\r\n  public on(eventName: string, callback: Function) {\r\n    eventName = Utils.slug(eventName);\r\n    if (eventName === \"\") {\r\n      throw new Error(\"Invalid event name\");\r\n    }\r\n    if (typeof callback !== \"function\") {\r\n      throw new Error(\"Invalid callback\");\r\n    }\r\n    Emitter.on(eventName, callback);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove a listener from an event\r\n   * @param eventName Event to remove listener from\r\n   * @param callback Callback to remove\r\n   * @returns This instance\r\n   * @example\r\n   * pubsub.off(\"message\", (data) => {\r\n   *  console.log(data);\r\n   * });\r\n   */\r\n  public off(eventName: string, callback: Function) {\r\n    eventName = Utils.slug(eventName);\r\n    if (eventName === \"\") {\r\n      throw new Error(\"Invalid event name\");\r\n    }\r\n    if (typeof callback !== \"function\") {\r\n      throw new Error(\"Invalid callback\");\r\n    }\r\n    Emitter.removeListener(eventName, callback);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Connect to the pubsub websocket (if not already connected) if autoConnect option is disabled\r\n   * @returns This instance (for chaining) or throws an error if autoConnect is enabled\r\n   * @example\r\n   * pubsub.connect().then(() => {\r\n   *  console.log(\"Connected!\");\r\n   * });\r\n   */\r\n  public connect() {\r\n    if (Options.get().autoConnect) {\r\n      throw new Error(\"autoConnect is enabled\");\r\n    }\r\n    if (PubSub.state() !== \"CONNECTED\") {\r\n      return this.__connect();\r\n    } else {\r\n      return Promise.resolve(this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reconnect to pubsub websocket if autoReconnect option is disabled\r\n   * @returns This instance (for chaining) or throws an error if autoReconnect is enabled\r\n   * @example\r\n   * pubsub.reconnect().then(() => {\r\n   *  console.log(\"Reconnected!\");\r\n   * });\r\n   */\r\n  public reconnect() {\r\n    if (Options.get().autoReconnect) {\r\n      throw new Error(\"autoReconnect is enabled\");\r\n    } else {\r\n      return this.__reconnect();\r\n    }\r\n  }\r\n\r\n  /** Disconnect from the pubsub websocket\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.disconnect().then(() => {\r\n   *  console.log(\"Disconnected!\");\r\n   * });\r\n   */\r\n  public disconnect() {\r\n    return this.__disconnect();\r\n  }\r\n\r\n  /** Get the last latency measurement\r\n   * @returns Latency in milliseconds\r\n   * @example\r\n   * console.log(pubsub.lastLatency());\r\n   * // => 1234\r\n   */\r\n  public lastLatency() {\r\n    return this.__latency;\r\n  }\r\n\r\n  /**\r\n   * Subscribe to a topic or topics (if an array is provided)\r\n   * @param topics Topics to subscribe to\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.subscribe(\"test\").then(() => {\r\n   *  console.log(\"Subscribed!\");\r\n   * });\r\n   */\r\n  public subscribe(topics: string[]) {\r\n    return this.__subscribe(topics);\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from a topic or topics (if an array is provided)\r\n   * @param topics Topics to unsubscribe from (if omitted, all topics are unsubscribed)\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.unsubscribe(\"test\").then(() => {\r\n   *  console.log(\"Unsubscribed!\");\r\n   * });\r\n   */\r\n  public unsubscribe(topics: string[]) {\r\n    return this.__unsubscribe(topics);\r\n  }\r\n\r\n  /**\r\n   * Get all topics registered\r\n   * @returns Array of topics\r\n   */\r\n  public registeredTopics() {\r\n    return Options.get().topics || [];\r\n  }\r\n\r\n  /**\r\n   * Get the number of topics registered\r\n   */\r\n  public registeredTopicsCount() {\r\n    return Options.get().topics.length;\r\n  }\r\n\r\n  /**\r\n   * Check if a topic is registered\r\n   * @param topic Topic to check\r\n   * @returns\r\n   */\r\n  public isRegisteredTopic(topic: string) {\r\n    return Options.get().topics.includes(topic);\r\n  }\r\n\r\n  /**\r\n   * Connection status of the pubsub websocket\r\n   * @returns Connection state (\"CONNECTED\", \"CONNECTING\", \"DISCONNECTING\", \"DISCONNECTED\")\r\n   * @example\r\n   * if (pubsub.state() === \"CONNECTED\") {\r\n   *  console.log(\"Connected!\");\r\n   * }\r\n   */\r\n  public state() {\r\n    return PubSub.state();\r\n  }\r\n}\r\n\r\nwindow.AnotherTwitchPubSub = AnotherTwitchPubSub;\r\n\r\ndeclare global {\r\n  interface Window {\r\n    AnotherTwitchPubSub: typeof AnotherTwitchPubSub;\r\n  }\r\n}\r\n","/**\r\n * Client\r\n */\r\nimport EventEmitter from \"./EventEmitter\";\r\nimport WebSocket from \"./WebSocket\";\r\nexport default class Client extends EventEmitter {\r\n  private client: WebSocket;\r\n  private heartbeatInterval: any;\r\n  private heartbeatIntervalMs: number = 6e4; // 60 seconds\r\n  /**\r\n   * Connect to the websocket\r\n   * @returns A promise with the websocket connection\r\n   */\r\n  public async connect() {\r\n    await new Promise((resolve, reject) => {\r\n      this.client = new WebSocket(\"wss://pubsub-edge.twitch.tv\");\r\n      this.client.onopen = (data: Event) => {\r\n        this.emit(\"connected\", data);\r\n        this.heartbeatInterval = setInterval(\r\n          () => this.heartbeat(),\r\n          this.heartbeatIntervalMs\r\n        );\r\n        resolve(data);\r\n      };\r\n      this.client.onclose = (event: CloseEvent) => {\r\n        const data = {\r\n          code: event.code,\r\n          reason: event.reason,\r\n          message: null,\r\n          wasClean: event.wasClean,\r\n        };\r\n        switch (event.code) {\r\n          case 1000:\r\n            data.message = \"Normal closure\";\r\n            break;\r\n          case 1001:\r\n            data.message = \"Going away\";\r\n            break;\r\n          case 1002:\r\n            data.message = \"Protocol error\";\r\n            break;\r\n          case 1003:\r\n            data.message = \"Unsupported data\";\r\n            break;\r\n          case 1006:\r\n            data.message = \"Abnormal closure\";\r\n            break;\r\n          case 1007:\r\n            data.message = \"Invalid data\";\r\n            break;\r\n          case 1008:\r\n            data.message = \"Policy violation\";\r\n            break;\r\n          case 1009:\r\n            data.message = \"data.Message too big\";\r\n            break;\r\n          case 1010:\r\n            data.message = \"Mandatory extension\";\r\n            break;\r\n          case 1011:\r\n            data.message = \"Internal server error\";\r\n            break;\r\n          default:\r\n            data.message = \"Unknown error\";\r\n            break;\r\n        }\r\n        this.emit(\"disconnected\", data);\r\n        clearInterval(this.heartbeatInterval);\r\n        reject(new Error(data.message));\r\n      };\r\n      this.client.onerror = (error: Event) => {\r\n        this.emit(\"error\", error);\r\n        reject(error);\r\n      };\r\n      this.client.onmessage = (data: MessageEvent) => {\r\n        this.emit(\"raw\", data);\r\n        const message = JSON.parse(data.data);\r\n        switch (message.type) {\r\n          case \"PONG\":\r\n            this.emit(\"pong\", Date.now());\r\n            break;\r\n          case \"MESSAGE\":\r\n            this.emit(\"message\", message);\r\n            break;\r\n          case \"RESPONSE\":\r\n            if (message.error) {\r\n              this.emit(`error:${message.nonce}`, message);\r\n            } else {\r\n              this.emit(`response:${message.nonce}`, message);\r\n            }\r\n            this.emit(\"response\", message);\r\n            break;\r\n          case \"DISCONNECT\":\r\n            this.emit(\"disconnect\", message);\r\n            break;\r\n          case \"RECONNECT\":\r\n            this.emit(\"reconnect\", message);\r\n            break;\r\n          default:\r\n            this.emit(\"unknown\", message);\r\n            break;\r\n        }\r\n      };\r\n    });\r\n    return this.client;\r\n  }\r\n  /**\r\n   * Disconnect from the websocket\r\n   */\r\n  public disconnect() {\r\n    this.client.close();\r\n  }\r\n  /**\r\n   * Send a message to the websocket\r\n   * @param data Data to send to the websocket\r\n   */\r\n  public async send(data: any) {\r\n    this.client.send(JSON.stringify(data));\r\n    if (data.nonce) {\r\n      return await this.waitForResponse(data.nonce);\r\n    }\r\n  }\r\n  /**\r\n   * Wait for a response to a message\r\n   */\r\n  private async waitForResponse(nonce: string) {\r\n    return new Promise((resolve, reject) => {\r\n      this.once(`response:${nonce}`, (response: any) => {\r\n        resolve(response);\r\n      });\r\n      this.once(`error:${nonce}`, (error: any) => {\r\n        reject(error);\r\n      });\r\n      this.once(`timeout:${nonce}`, () => {\r\n        reject(new Error(\"Timeout\"));\r\n      });\r\n\r\n      setTimeout(() => {\r\n        this.emit(`timeout:${nonce}`);\r\n      }, 1000);\r\n    })\r\n      .then((response: any) => {\r\n        this.removeAllListeners(`response:${nonce}`);\r\n        this.removeAllListeners(`error:${nonce}`);\r\n        this.removeAllListeners(`timeout:${nonce}`);\r\n        return response;\r\n      })\r\n      .catch((error: any) => {\r\n        this.removeAllListeners(`response:${nonce}`);\r\n        this.removeAllListeners(`error:${nonce}`);\r\n        this.removeAllListeners(`timeout:${nonce}`);\r\n        throw error;\r\n      });\r\n  }\r\n  /**\r\n   * Heartbeat\r\n   */\r\n  private heartbeat() {\r\n    this.emit(\"ping\", Date.now());\r\n    this.send({\r\n      type: \"PING\",\r\n    });\r\n  }\r\n  /**\r\n   * State of the websocket\r\n   */\r\n  public state() {\r\n    switch (this.client?.readyState) {\r\n      case WebSocket.CONNECTING:\r\n        return \"CONNECTING\";\r\n      case WebSocket.OPEN:\r\n        return \"CONNECTED\";\r\n      case WebSocket.CLOSING:\r\n        return \"DISCONNECTING\";\r\n      case WebSocket.CLOSED:\r\n      default:\r\n        return \"DISCONNECTED\";\r\n    }\r\n  }\r\n}\r\n"],"names":["__webpack_require__","g","globalThis","this","Function","e","window","EventEmitter","events","event","data","let","count","Promise","async","resolve","Array","isArray","all","map","emit","then","key","hasOwnProperty","forEach","listener","includes","eventName","split","startsWith","toLowerCase","on","callback","push","removeListener","filter","cb","removeAllListeners","once","ws","WebSocket","self","Error","options","accessToken","topics","autoConnect","autoReconnect","reconnectInterval","reconnectAttempts","set","Object","assign","get","setToken","setTopics","findTopic","topic","indexOf","addTopic","removeTopic","index","splice","addTopics","removeTopics","isEmpty","obj","length","keys","arrayLowerCase","arr","item","repeat","fn","times","result","i","nonce","Math","random","toString","substring","join","toCamelCase","str","replace","$1","toUpperCase","slug","sep","RegExp","slugToCamelCase","removeDuplicates","res","fetch","headers","Authorization","Options","json","user","find","name","api","validateToken","client_id","login","user_id","id","err","console","log","isNumber","isNaN","Number","isValidTopic","getTopicsFormat","error","topicName","channelBitsEventsV1","channelBitsEventsV2","channelBitsBadgeUnlocks","channelPointsChannelV1","channelSubscribeEventsV1","chatModeratorActions","automodQueue","userModerationNotifications","whispers","filterTopics","arg1","arg2","topicFormat","getUserId","validade","parseTopic","PubSub","heartbeatIntervalMs","reject","client","onopen","heartbeatInterval","setInterval","heartbeat","onclose","code","reason","message","wasClean","clearInterval","onerror","onmessage","JSON","parse","type","Date","now","disconnect","close","send","stringify","waitForResponse","response","setTimeout","catch","state","readyState","Emitter","AnotherTwitchPubSub","constructor","__latency","__timestamp","__connect","__onConnection","__onDisconnection","__onEventError","__onEventMessage","__onPingSent","__onPongReceived","__onRawMessage","__onResponseMessage","connect","attempts","__reconnect","Utils","parseTopics","auth_token","__send","__emit","__subscribe","__emitErrorEvent","messageType","messageData","__onChannelPointsEvent","__onBitsEvent","__onSubEvent","__onWhisperEvent","data_object","errorMessage","timestamp","latency","context","userId","userName","user_name","displayName","display_name","channelId","channel_id","channelName","channel_name","time","subPlan","sub_plan","subPlanName","sub_plan_name","isGift","is_gift","months","cumulativeMonths","cumulative_months","streakMonths","streak_months","subMessage","sub_message","recipientId","recipient_id","recipientUserName","recipient_user_name","recipientDisplayName","recipient_display_name","multiMonthDuration","multi_month_duration","redemption","args","off","reconnect","__disconnect","lastLatency","subscribe","unsubscribe","__unsubscribe","registeredTopics","registeredTopicsCount","isRegisteredTopic"],"sourceRoot":""}