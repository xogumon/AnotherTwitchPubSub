{"version":3,"file":"bundle.min.js","mappings":"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","sources":["webpack://anothertwitchpubsub/webpack/bootstrap","webpack://anothertwitchpubsub/webpack/runtime/global","webpack://anothertwitchpubsub/./src/modules/EventEmitter.ts","webpack://anothertwitchpubsub/./src/modules/WebSocket.ts","webpack://anothertwitchpubsub/./src/modules/Options.ts","webpack://anothertwitchpubsub/./src/modules/Utils.ts","webpack://anothertwitchpubsub/./src/index.ts","webpack://anothertwitchpubsub/./src/modules/Client.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","/**\r\n * EventEmitter\r\n */\r\nexport default class EventEmitter {\r\n  private events: { [event: string]: Function[] } = {};\r\n  /**\r\n   * Emit an event\r\n   * @param event Event to emit\r\n   * @param data Data to emit\r\n   * @returns Returns a promise with a number of emitted events\r\n   * @example\r\n   * emitter.emit('event', 'data');\r\n   */\r\n  public async emit(event: string | string[], ...data: any[]) {\r\n    let count: number = 0;\r\n    await new Promise(async (resolve) => {\r\n      if (Array.isArray(event)) {\r\n        await Promise.all(\r\n          event.map(async (e: string) => {\r\n            await this.emit(e, ...data).then(() => {\r\n              count++;\r\n            });\r\n          })\r\n        );\r\n      } else if (event === \"*\") {\r\n        for (const key in this.events) {\r\n          if (this.events.hasOwnProperty(key)) {\r\n            this.events[key].forEach((listener) => {\r\n              count++;\r\n              listener(...data);\r\n            });\r\n          }\r\n        }\r\n      } else if (typeof event === \"string\" && event.includes(\"*\")) {\r\n        const [eventName, ...rest] = event.split(\"*\");\r\n        for (const key in this.events) {\r\n          if (this.events.hasOwnProperty(key) && key.startsWith(eventName)) {\r\n            this.events[key].forEach((listener) => {\r\n              count++;\r\n              listener(...data);\r\n            });\r\n          }\r\n        }\r\n      } else if (\r\n        typeof event === \"string\" &&\r\n        event.toLowerCase() in this.events\r\n      ) {\r\n        this.events[event.toLowerCase()].forEach((listener) => {\r\n          count++;\r\n          listener(...data);\r\n        });\r\n      }\r\n      resolve(count);\r\n    });\r\n    return `Emitted ${count} events to listeners`;\r\n  }\r\n  /**\r\n   * Listen to an event\r\n   * @param event Event to listen to\r\n   * @param callback Callback to execute when the event is emitted\r\n   * @example\r\n   * emitter.on('event', (data) => {\r\n   *   console.log(data);\r\n   * });\r\n   * emitter.emit('event', 'data'); // Outputs 'data'\r\n   */\r\n  public on(event: string | string[], callback: Function) {\r\n    if (Array.isArray(event)) {\r\n      event.map((e: string) => {\r\n        this.on(e, callback);\r\n      });\r\n    } else if (typeof event === \"string\") {\r\n      if (!this.events[event]) {\r\n        this.events[event] = [];\r\n      }\r\n      this.events[event].push(callback);\r\n    }\r\n  }\r\n  /**\r\n   * Remove an event listener\r\n   * @param event Event to remove listener from\r\n   * @param callback Callback to remove\r\n   * @example\r\n   * const callback = (data) => {\r\n   *   console.log(data);\r\n   * };\r\n   * emitter.on('event', callback);\r\n   * emitter.emit('event', 'data'); // Outputs 'data'\r\n   * emitter.removeListener('event', callback);\r\n   * emitter.emit('event', 'data'); // Doesn't output 'data'\r\n   */\r\n  public removeListener(event: string, callback: Function) {\r\n    if (this.events[event]) {\r\n      this.events[event] = this.events[event].filter(\r\n        (cb: Function) => cb !== callback\r\n      );\r\n    }\r\n  }\r\n  /**\r\n   * Remove all event listeners for an event\r\n   * @param event Event to remove listeners from\r\n   * @example\r\n   * emitter.on('event', (data) => {\r\n   *   console.log(data);\r\n   * });\r\n   * emitter.emit('event', 'data'); // Outputs 'data'\r\n   * emitter.removeAllListeners('event');\r\n   * emitter.emit('event', 'data'); // Doesn't output 'data'\r\n   */\r\n  public removeAllListeners(event: string) {\r\n    if (this.events[event]) {\r\n      this.events[event] = [];\r\n    }\r\n  }\r\n  /**\r\n   * Once an event is emitted, remove all event listeners for that event\r\n   * @param event Event to remove listeners from\r\n   * @example\r\n   * emitter.once('event', (data) => {\r\n   *   console.log(data);\r\n   * });\r\n   * emitter.emit('event', 'data'); // Outputs 'data'\r\n   * emitter.emit('event', 'data'); // Doesn't output 'data'\r\n   */\r\n  public once(event: string, callback: Function) {\r\n    this.on(event, (data: any) => {\r\n      this.removeListener(event, callback);\r\n      callback(data);\r\n    });\r\n  }\r\n}\r\n","let ws:\r\n  | typeof WebSocket\r\n  | typeof global.WebSocket\r\n  | typeof window.WebSocket\r\n  | typeof self.WebSocket =\r\n  WebSocket || global.WebSocket || window.WebSocket || self.WebSocket;\r\n\r\nif (!ws) {\r\n  throw new Error(\"WebSocket is not supported by this browser.\");\r\n}\r\n\r\nexport default ws;\r\n","/**\r\n * Options\r\n */\r\nexport interface thisOptions {\r\n  /**\r\n   * Options\r\n   */\r\n  accessToken: string;\r\n  topics: string[];\r\n  autoConnect: boolean;\r\n  autoReconnect: boolean;\r\n  reconnectInterval: number;\r\n  reconnectAttempts: number;\r\n}\r\nclass AnotherTwitchPubSubOptions {\r\n  /**\r\n   * Store the options.\r\n   */\r\n  private options: thisOptions = {\r\n    accessToken: \"\",\r\n    topics: [],\r\n    autoConnect: true,\r\n    autoReconnect: true,\r\n    reconnectInterval: 10000,\r\n    reconnectAttempts: 10,\r\n  };\r\n\r\n  /**\r\n   * Set the options.\r\n   */\r\n  public set(options: thisOptions) {\r\n    this.options = Object.assign({}, this.options, options);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Get the options.\r\n   */\r\n  public get() {\r\n    return this.options;\r\n  }\r\n\r\n  /**\r\n   * Set the access token.\r\n   * @param accessToken The access token to use.\r\n   * @returns This instance.\r\n   */\r\n  public setToken(accessToken: string) {\r\n    this.options.accessToken = accessToken;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the topics to subscribe to.\r\n   * @param topics The topics to subscribe to.\r\n   * @returns This instance.\r\n   */\r\n  public setTopics(topics: string[]) {\r\n    this.options.topics = topics;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Find a topic in the topics.\r\n   * @param topic The topic to find.\r\n   */\r\n  public findTopic(topic: string) {\r\n    return this.options.topics.indexOf(topic) > -1;\r\n  }\r\n\r\n  /**\r\n   * Add a topic to the topics.\r\n   * @param topic The topic to add.\r\n   */\r\n  public addTopic(topic: string) {\r\n    if (!this.options.topics.includes(topic)) {\r\n      this.options.topics.push(topic);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove a topic from the topics.\r\n   * @param topic The topic to remove.\r\n   */\r\n  public removeTopic(topic: string) {\r\n    const index = this.options.topics.indexOf(topic);\r\n    if (index > -1) {\r\n      this.options.topics.splice(index, 1);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add topics to the topics.\r\n   * @param topics The topics to add.\r\n   */\r\n  public addTopics(topics: string[]) {\r\n    if (!Array.isArray(topics)) {\r\n      this.addTopic(topics);\r\n    } else {\r\n      for (const topic of topics) {\r\n        this.addTopic(topic);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove topics from the topics.\r\n   * @param topics The topics to remove.\r\n   */\r\n  public removeTopics(topics: string[]) {\r\n    if (!Array.isArray(topics)) {\r\n      this.removeTopic(topics);\r\n    } else {\r\n      for (const topic of topics) {\r\n        this.removeTopic(topic);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n}\r\nexport default new AnotherTwitchPubSubOptions();\r\n","import Options from \"./Options\";\r\nexport default {\r\n  /**\r\n   * isEmpty\r\n   * @param obj Object to check\r\n   * @returns True if the object is empty, false otherwise\r\n   */\r\n  isEmpty(obj: any) {\r\n    if (\r\n      obj === \"\" ||\r\n      obj === 0 ||\r\n      obj === false ||\r\n      obj === null ||\r\n      obj === undefined\r\n    ) {\r\n      return true;\r\n    }\r\n    if (Array.isArray(obj)) {\r\n      return obj.length === 0;\r\n    } else if (typeof obj === \"object\") {\r\n      return Object.keys(obj).length === 0;\r\n    }\r\n    return false;\r\n  },\r\n  /**\r\n   * Lowercase a array items\r\n   * @param arr Array to lowercase\r\n   * @returns Array with all items lowercased\r\n   * @example\r\n   * const arr = ['THIS', 'IS', 'A', 'TEST'];\r\n   * const lowercased = arrayLowerCase(arr);\r\n   * console.log(lowercased); // ['this', 'is', 'a', 'test']\r\n   */\r\n  arrayLowerCase(arr: any[]) {\r\n    return arr.map((item) => item.toLowerCase());\r\n  },\r\n  /**\r\n   * Repeat a method a number of times\r\n   * @param fn Method to repeat\r\n   * @param times Number of times to repeat\r\n   * @returns Array with the repeated method\r\n   * @example\r\n   * const repeat = repeat(() => 1, 5);\r\n   * console.log(repeat); // [1, 1, 1, 1, 1]\r\n   */\r\n  repeat(fn: Function, times: number) {\r\n    let result = [];\r\n    for (let i = 0; i < times; i++) {\r\n      result.push(fn());\r\n    }\r\n    return result;\r\n  },\r\n  /**\r\n   * Generate a random nonce\r\n   * @returns Random nonce\r\n   */\r\n  nonce() {\r\n    const random = () => Math.random().toString(36).substring(2, 15);\r\n    return this.repeat(random, 2).join(\"\");\r\n  },\r\n  /**\r\n   * Convert a string to a camelCase string\r\n   */\r\n  toCamelCase(str: string) {\r\n    return str.replace(/\\s(.)/g, ($1) => $1.toUpperCase());\r\n  },\r\n  /**\r\n   * Slugify a string\r\n   * @param str String to slugify\r\n   * @param sep Separator to use\r\n   * @returns Slugified string\r\n   * @example\r\n   * const slug = slug(\"This is a string\", \"-\");\r\n   * console.log(slug); // this-is-a-string\r\n   */\r\n  slug(str: string, sep: string = \"-\") {\r\n    if (typeof str !== \"string\") return \"\";\r\n    if (typeof sep !== \"string\") sep = \"-\";\r\n    str = str.toLowerCase().replace(/[^a-z0-9]/g, sep); // replace all non-alphanumeric characters with the separator\r\n    if (sep.length > 0) {\r\n      str = str\r\n        .replace(new RegExp(`${sep}{2,}`, \"g\"), sep) // replace multiple separators with a single one\r\n        .replace(new RegExp(`^${sep}|${sep}$`, \"g\"), \"\"); // remove leading and trailing separators\r\n    }\r\n    return str; // return the slug\r\n  },\r\n  /**\r\n   * Slugify to camelCase string\r\n   * @param str String to slugify\r\n   * @returns Slugified string in camelCase without separators\r\n   * @example\r\n   * const slug = slugToCamelCase(\"This is a string\");\r\n   * console.log(slug); // thisIsAString\r\n   */\r\n  slugToCamelCase(str: string) {\r\n    return this.slug(str)\r\n      .replace(/-([a-z])/g, ($1: string) => $1.toUpperCase())\r\n      .replace(/-/g, \"\");\r\n  },\r\n  /**\r\n   * Remove duplicate values from an array\r\n   * @param arr Array to remove duplicates from\r\n   * @returns Array with no duplicates\r\n   * @example\r\n   * const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n   * const unique = removeDuplicates(arr);\r\n   * console.log(unique); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n   */\r\n  removeDuplicates(arr: any[]) {\r\n    return arr.filter((item, index) => arr.indexOf(item) === index);\r\n  },\r\n  /**\r\n   * Validate a token with Twitch's API\r\n   * @returns Validation result from Twitch's API\r\n   */\r\n  async validateToken() {\r\n    const res = await fetch(\"https://id.twitch.tv/oauth2/validate\", {\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: `OAuth ${Options.get().accessToken}`,\r\n      },\r\n    });\r\n    return await res.json();\r\n  },\r\n  /**\r\n   * Get user data from Twitch's API\r\n   * @param user User to get the ID of\r\n   * @returns Array containing the user's ID\r\n   * @example\r\n   * const user = \"twitch\";\r\n   * const token = \"oauth:token\";\r\n   * const id = await getUserId(user, token);\r\n   * console.log(id); // [1234]\r\n   */\r\n  async getUserId(user: any) {\r\n    let find: string;\r\n    if (typeof user === \"string\") {\r\n      find = `login=${user}`;\r\n    } else if (typeof user === \"object\") {\r\n      find = user.map((name: string) => `login=${name}`).join(\"&\");\r\n    } else {\r\n      throw new Error(\"User must be a string or an array of strings\");\r\n    }\r\n    try {\r\n      const api = await this.validateToken();\r\n      if (api.client_id) {\r\n        if (api.login === user.toLowerCase()) {\r\n          return [api.user_id];\r\n        } else {\r\n          const res = await fetch(`https://api.twitch.tv/helix/users?${find}`, {\r\n            headers: {\r\n              \"Client-ID\": api.client_id,\r\n              Authorization: `Bearer ${Options.get().accessToken}`,\r\n            },\r\n          });\r\n          const data = await res.json();\r\n          if (data.data.length > 0) {\r\n            return data.data.map((user: any) => user.id);\r\n          } else {\r\n            throw new Error(\"User not found\");\r\n          }\r\n        }\r\n      } else {\r\n        throw new Error(\"Invalid token\");\r\n      }\r\n    } catch (err) {\r\n      return console.log(err);\r\n    }\r\n  },\r\n  /**\r\n   * Returns if string is a number or not\r\n   */\r\n  isNumber(str: string) {\r\n    return !isNaN(Number(str));\r\n  },\r\n\r\n  /**\r\n   * Check if an topic is valid\r\n   * @param topic Topic to check\r\n   * @returns True if topic is valid, false otherwise\r\n   * @example\r\n   * console.log(isValidTopic('channel-bits-events-v2')); // true\r\n   * console.log(isValidTopic('channel-bits-events-v3')); // false\r\n   */\r\n  isValidTopic(topic: string) {\r\n    try {\r\n      if (typeof topic !== \"string\") {\r\n        throw new Error(\"Invalid topic\");\r\n      }\r\n      if (topic.length > 100) {\r\n        throw new Error(\"Topic is too long\");\r\n      }\r\n      if (topic.length < 5) {\r\n        throw new Error(\"Topic is too short\");\r\n      }\r\n      if (topic.includes(\" \")) {\r\n        throw new Error(\"Topic cannot contain spaces\");\r\n      }\r\n      if (!this.getTopicsFormat(topic)) {\r\n        throw new Error(\"Topic is invalid\");\r\n      }\r\n      return true;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  },\r\n  /**\r\n   * Returns a correct format of a topic\r\n   * @param topicName Topic to format\r\n   * @returns Formatted topic\r\n   */\r\n  getTopicsFormat(topicName: string) {\r\n    topicName = this.slugToCamelCase(topicName);\r\n    const validTopics = {\r\n      channelBitsEventsV1: \"channel-bits-events-v2.$arg1$\",\r\n      channelBitsEventsV2: \"channel-bits-events-v2.$arg1$\",\r\n      channelBitsBadgeUnlocks: \"channel-bits-badge-unlocks.$arg1$\",\r\n      channelPointsChannelV1: \"channel-points-channel-v1.$arg1$\",\r\n      channelSubscribeEventsV1: \"channel-subscribe-events-v2.$arg1$\",\r\n      chatModeratorActions: \"chat_moderator_actions.$arg1$.$arg2$\",\r\n      automodQueue: \"automod-queue.$arg1$.$arg2$\",\r\n      userModerationNotifications:\r\n        \"user-moderation-notifications.$arg1$.$arg2$\",\r\n      whispers: \"whispers.$arg1$\",\r\n    };\r\n    return validTopics[topicName];\r\n  },\r\n  /**\r\n   * Filter an array of topics\r\n   * @param topics Array of topics to filter\r\n   * @returns Array of valid topics\r\n   */\r\n  filterTopics(topics: string[]) {\r\n    topics = this.arrayLowerCase(topics);\r\n    topics = this.removeDuplicates(topics);\r\n    return topics.filter((topic: string) => this.isValidTopic(topic));\r\n  },\r\n  /**\r\n   * Parse a topic to get the arguments\r\n   * @param topic Topic to parse\r\n   * @returns Array of arguments\r\n   */\r\n  async parseTopic(topic: string) {\r\n    let [topicName, arg1, arg2] = topic.split(\".\");\r\n    const topicFormat = this.getTopicsFormat(topicName);\r\n    if (topicFormat) {\r\n      if (arg1 || arg2) {\r\n        if (!this.isNumber(arg1) && !this.isNumber(arg2)) {\r\n          [arg1, arg2] = await this.getUserId([arg1, arg2]);\r\n        } else if (!this.isNumber(arg1)) {\r\n          [arg1] = await this.getUserId(arg1);\r\n        } else if (!this.isNumber(arg2)) {\r\n          [arg2] = await this.getUserId(arg2);\r\n        }\r\n      } else {\r\n        const validade = await this.validateToken();\r\n        if (validade.login) {\r\n          arg1 = validade.user_id;\r\n          arg2 = validade.user_id;\r\n        } else {\r\n          throw new Error(\"Invalid token\");\r\n        }\r\n      }\r\n      if (this.isNumber(arg1) && this.isNumber(arg2)) {\r\n        return topicFormat.replace(\"$arg1$\", arg1).replace(\"$arg2$\", arg2);\r\n      } else {\r\n        return topicFormat.replace(\"$arg1$\", arg1);\r\n      }\r\n    }\r\n    return null;\r\n  },\r\n  /**\r\n   * Parse array of topics to get the arguments\r\n   * @param topics Array of topics to parse\r\n   * @returns Array of arguments\r\n   */\r\n  async parseTopics(topics: string[]) {\r\n    this.filterTopics(topics);\r\n    return await Promise.all(\r\n      topics.map((topic: string) => this.parseTopic(topic))\r\n    );\r\n  },\r\n};\r\n","import Client from \"./modules/Client\";\r\nimport EventEmitter from \"./modules/EventEmitter\";\r\nimport Options from \"./modules/Options\";\r\nimport Utils from \"./modules/Utils\";\r\nconst PubSub = new Client();\r\nconst Emitter = new EventEmitter();\r\n/**\r\n * @class AnotherTwitchPubSub\r\n * @author Ronis Xogum <ronis@xogum.net> (https://github.com/xogumon)\r\n * @version 1.0.0\r\n * @description A simple Twitch PubSub client\r\n * @license MIT\r\n * @param {string} accessToken - The authentication token of the channel you want to subscribe to.\r\n * @param {boolean} autoConnect - Whether or not to automatically connect to Twitch PubSub.\r\n * @param {boolean} autoReconnect - Whether or not to automatically reconnect to Twitch PubSub if the connection is lost.\r\n * @param {number} reconnectAttempts - The number of reconnect attempts to make before giving up.\r\n * @param {number} reconnectInterval - The time in milliseconds between reconnect attempts.\r\n * @param {string[]} topics - The topics you want to subscribe to.\r\n * @example\r\n * new TwitchPubSub({\r\n *  accessToken: 'authToken',\r\n *  topics: ['topic1', 'topic2']\r\n * }).on('message', (topic, message) => {\r\n *  console.log(topic, message);\r\n * });\r\n */\r\nclass AnotherTwitchPubSub {\r\n  private __latency: number = 0;\r\n  private __timestamp: number = 0;\r\n  constructor(options: any) {\r\n    Options.set(options);\r\n    if (Options.get().autoConnect) this.__connect();\r\n    PubSub.on(\"connected\", () => this.__onConnection());\r\n    PubSub.on(\"disconnected\", (event: any) => this.__onDisconnection(event));\r\n    PubSub.on(\"error\", (event: any) => this.__onEventError(event));\r\n    PubSub.on(\"message\", (event: any) => this.__onEventMessage(event));\r\n    PubSub.on(\"ping\", (event: any) => this.__onPingSent(event));\r\n    PubSub.on(\"pong\", (event: any) => this.__onPongReceived(event));\r\n    PubSub.on(\"raw\", (event: any) => this.__onRawMessage(event));\r\n    PubSub.on(\"response\", (event: any) => this.__onResponseMessage(event));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Connect to the pubsub websocket\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.__connect().then(() => {\r\n   *  console.log(\"Connected!\");\r\n   * });\r\n   */\r\n  private async __connect() {\r\n    await new Promise((resolve, reject) => {\r\n      if (PubSub.state() === \"DISCONNECTED\") {\r\n        PubSub.connect()\r\n          .then(() => {\r\n            resolve(null);\r\n          })\r\n          .catch((e: any) => {\r\n            reject(e);\r\n          });\r\n      } else {\r\n        resolve(null);\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Disconnect from the pubsub websocket\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.__disconnect().then(() => {\r\n   *  console.log(\"Disconnected!\");\r\n   * });\r\n   */\r\n  private async __disconnect() {\r\n    await new Promise((resolve) => {\r\n      if (PubSub.state() === \"CONNECTED\") {\r\n        PubSub.disconnect();\r\n      } else if (PubSub.state() === \"DISCONNECTED\") {\r\n        resolve(null);\r\n      }\r\n      PubSub.on(\"disconnected\", () => {\r\n        resolve(null);\r\n      });\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /** Reconnect to the pubsub websocket\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.reconnect().then(() => {\r\n   *  console.log(\"Reconnected!\");\r\n   * });\r\n   */\r\n  private async __reconnect(attempts: number = 0) {\r\n    await new Promise((resolve, reject) => {\r\n      function connect() {\r\n        setTimeout(() => {\r\n          PubSub.connect()\r\n            .then(() => {\r\n              resolve(null);\r\n            })\r\n            .catch((e: any) => {\r\n              setTimeout(() => {\r\n                this.__reconnect(attempts + 1);\r\n              }, Options.get().reconnectInterval);\r\n              reject(e);\r\n            });\r\n        }, Options.get().reconnectInterval);\r\n      }\r\n      if (PubSub.state() === \"CONNECTING\") {\r\n        reject(new Error(\"Already reconnecting\"));\r\n      }\r\n      if (attempts >= Options.get().reconnectAttempts) {\r\n        reject(new Error(\"Reconnect attempts exceeded\"));\r\n      }\r\n      if (PubSub.state() === \"DISCONNECTED\") {\r\n        connect();\r\n      }\r\n      if (PubSub.state() === \"CONNECTED\") {\r\n        if (attempts === 0) {\r\n          PubSub.disconnect();\r\n          PubSub.on(\"disconnected\", () => {\r\n            connect();\r\n          });\r\n        }\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Send a message to the pubsub websocket\r\n   * @param data Data to send\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.__send({\r\n   *  type: \"PING\"\r\n   * }).then(() => {\r\n   *  console.log(\"Message sent!\");\r\n   * });\r\n   */\r\n  private async __send(data: object) {\r\n    if (PubSub.state() === \"CONNECTED\") {\r\n      return await PubSub.send(data);\r\n    } else {\r\n      throw new Error(\"Not connected\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribe to a topic or topics (if an array is provided)\r\n   * @param topics Topics to subscribe to\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.__subscribe(\"test\").then(() => {\r\n   *  console.log(\"Subscribed!\");\r\n   * });\r\n   */\r\n  private async __subscribe(topics: string[]) {\r\n    await new Promise(async (resolve, reject) => {\r\n      if (PubSub.state() !== \"CONNECTED\") {\r\n        reject(new Error(\"Not connected\"));\r\n      } else {\r\n        if (!Array.isArray(topics)) {\r\n          topics = [topics];\r\n        }\r\n        topics = await Utils.parseTopics(topics);\r\n        if (topics.length > 0) {\r\n          const data = {\r\n            type: \"LISTEN\",\r\n            nonce: Utils.nonce(),\r\n            data: {\r\n              topics,\r\n              auth_token: Options.get().accessToken,\r\n            },\r\n          };\r\n          this.__send(data)\r\n            .then((response) => {\r\n              if (\r\n                response.type === \"RESPONSE\" &&\r\n                Utils.isEmpty(response.error)\r\n              ) {\r\n                this.__emit(\"subscribed\", topics);\r\n                resolve(Options.addTopics(topics));\r\n              } else {\r\n                reject(new Error(\"Subscription failed\"));\r\n              }\r\n            })\r\n            .catch((e) => {\r\n              reject(e);\r\n            });\r\n        } else {\r\n          resolve(null);\r\n        }\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from a topic or topics (if an array is provided)\r\n   * @param topics Topics to unsubscribe from (if omitted, all topics are unsubscribed)\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.__unsubscribe(\"test\").then(() => {\r\n   *  console.log(\"Unsubscribed!\");\r\n   * });\r\n   */\r\n  private async __unsubscribe(topics: string[]) {\r\n    await new Promise(async (resolve, reject) => {\r\n      if (PubSub.state() !== \"CONNECTED\") {\r\n        reject(new Error(\"Not connected\"));\r\n      } else {\r\n        if (!Array.isArray(topics)) {\r\n          topics = [topics];\r\n        }\r\n        topics = await Utils.parseTopics(topics ?? Options.get().topics);\r\n        if (topics.length > 0) {\r\n          const data = {\r\n            type: \"UNLISTEN\",\r\n            nonce: Utils.nonce(),\r\n            data: {\r\n              topics,\r\n              auth_token: Options.get().accessToken,\r\n            },\r\n          };\r\n          this.__send(data)\r\n            .then((response) => {\r\n              if (\r\n                response.type === \"RESPONSE\" &&\r\n                Utils.isEmpty(response.error)\r\n              ) {\r\n                this.__emit(\"unsubscribed\", topics);\r\n                resolve(Options.removeTopics(topics));\r\n              } else {\r\n                reject(new Error(\"Unsubscription failed\"));\r\n              }\r\n            })\r\n            .catch((e) => {\r\n              reject(e);\r\n            });\r\n        } else {\r\n          resolve(null);\r\n        }\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Open event handler (Client)\r\n   */\r\n  private __onConnection() {\r\n    if (Options.get().topics) this.__subscribe(Options.get().topics);\r\n    this.__emit(\"connected\");\r\n  }\r\n\r\n  /**\r\n   * Close event handler (Client)\r\n   * @param event Event\r\n   */\r\n  private __onDisconnection(event: CloseEvent) {\r\n    if (!event.wasClean && Options.get().autoReconnect) {\r\n      this.__reconnect();\r\n    }\r\n    this.__emit(\"disconnected\", event);\r\n  }\r\n\r\n  /**\r\n   * Message event handler (Client)\r\n   * @param event The event that was received\r\n   */\r\n  private __onRawMessage(event: MessageEvent) {\r\n    const eventData = JSON.parse(event.data);\r\n    const { type, data } = eventData;\r\n    switch (type) {\r\n      case \"LISTEN\":\r\n      case \"UNLISTEN\":\r\n        this.__emit(type, data);\r\n      case \"RECONNECT\":\r\n      case \"DISCONNECT\":\r\n        this.__emit(type);\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Error event handler (Client)\r\n   * @param event The event that was received\r\n   */\r\n  private __onEventError(event: ErrorEvent) {\r\n    this.__emitErrorEvent(event.error);\r\n  }\r\n\r\n  /**\r\n   * Error event handler\r\n   * @param event The error event\r\n   */\r\n  private __emitErrorEvent(event: any) {\r\n    if (event instanceof Error) {\r\n      this.__emit(\"error\", event.message);\r\n    } else {\r\n      this.__emit(\"error\", event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Message event handler\r\n   * @param data The event that was received\r\n   */\r\n  private __onEventMessage(data: any) {\r\n    // Emit raw message as message event\r\n    this.__emit(\"message\", data);\r\n    // Topic and messages (message is a data object from raw message)\r\n    const { topic, message } = data.data;\r\n    // Emit message event for topic\r\n    this.__emit(topic, JSON.parse(message));\r\n    // messageType is the type of topic and messageData is the data of the message\r\n    const { type: messageType, data: messageData } = JSON.parse(message);\r\n    const topicEvents = [\r\n      \"channel-points-channel\",\r\n      \"channel-bits-events\",\r\n      \"channel-bits-badge-unlocks\",\r\n      \"channel-subscribe-events\",\r\n      \"whispers\",\r\n    ];\r\n    // Find the event name for the topic\r\n    const eventName = topicEvents.find((event) => topic.includes(event));\r\n    // Handle events for each topic\r\n    switch (eventName) {\r\n      case \"channel-points-channel\":\r\n        // Channel points events\r\n        this.__onChannelPointsEvent({\r\n          type: messageType,\r\n          data: messageData,\r\n        });\r\n        break;\r\n      case \"channel-bits-events\":\r\n      case \"channel-bits-badge-unlocks\":\r\n        // Channel bits events and badge unlocks\r\n        this.__onBitsEvent({\r\n          type: eventName,\r\n          data: messageData,\r\n        });\r\n        break;\r\n      case \"channel-subscribe-events\":\r\n        // Channel subscription events\r\n        this.__onSubEvent(messageData);\r\n        break;\r\n      case \"whispers\":\r\n        // Whisper events\r\n        this.__onWhisperEvent({\r\n          type: messageData.type,\r\n          data: data.data_object,\r\n        });\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Response event handler\r\n   * @param data The response data\r\n   */\r\n  private __onResponseMessage(data: any) {\r\n    let errorMessage: string;\r\n    if (data?.error) {\r\n      switch (data.error) {\r\n        case \"ERR_BADAUTH\":\r\n          errorMessage = \"Invalid authentication token\";\r\n          break;\r\n        case \"ERR_BADTOPIC\":\r\n          errorMessage = \"Invalid topic\";\r\n          break;\r\n        case \"ERR_BADMESSAGE\":\r\n          errorMessage = \"Invalid message\";\r\n          break;\r\n        case \"ERR_SERVER\":\r\n          errorMessage = \"Server error\";\r\n          break;\r\n        default:\r\n          errorMessage = \"Unknown error\" + data.error;\r\n          break;\r\n      }\r\n      this.__emitErrorEvent(errorMessage);\r\n    } else {\r\n      if (data) this.__emit(\"response\", data);\r\n    }\r\n  }\r\n\r\n  private __onPingSent(timestamp: number) {\r\n    this.__timestamp = timestamp;\r\n    this.__emit(\"ping\");\r\n  }\r\n\r\n  /**\r\n   * Pong event handler\r\n   */\r\n  private __onPongReceived(timestamp: number) {\r\n    this.__latency = timestamp - this.__timestamp;\r\n    this.__emit(\"pong\", this.__latency);\r\n    if (this.__latency > 1e4) {\r\n      if (Options.get().autoReconnect) {\r\n        this.__reconnect();\r\n      } else {\r\n        // if latency is greater than 10 seconds\r\n        this.__emit(\"warning\", {\r\n          message: \"Latency is very high\",\r\n          latency: this.__latency,\r\n        });\r\n      }\r\n    } else if (this.__latency > 1e3) {\r\n      // if latency is greater than 1 second\r\n      this.__emit(\"warning\", {\r\n        message: \"Latency is high\",\r\n        latency: this.__latency,\r\n      });\r\n    } else if (this.__latency > 1e2) {\r\n      // if latency is greater than 100 milliseconds\r\n      this.__emit(\"warning\", {\r\n        message: \"Latency is medium\",\r\n        latency: this.__latency,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bits event handler\r\n   * @param data The data object\r\n   */\r\n  private __onBitsEvent({ type, data }: { type: string; data: any }) {\r\n    switch (type) {\r\n      case \"channel-bits-events\":\r\n        this.__emit(\"bits\", data);\r\n        break;\r\n      case \"channel-bits-badge-unlocks\":\r\n        this.__emit(\"bitsbadge\", data);\r\n        break;\r\n      default:\r\n        this.__emitErrorEvent(new Error(`Unknown message type: ${type}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscription event handler\r\n   * (sub, resub, subgift, anonsubgift)\r\n   * @param data The data object\r\n   */\r\n  private __onSubEvent(data: any) {\r\n    this.__emit(data.context, {\r\n      userId: data.user_id || null, // user id of the user who subscribed\r\n      userName: data.user_name || null, // user name of the user who subscribed\r\n      displayName: data.display_name || null, // display name of the user who subscribed\r\n      channelId: data.channel_id, // channel id of the channel the subscription was made in\r\n      channelName: data.channel_name, // channel name of the channel the subscription was made in\r\n      time: data.time, // time the subscription was made\r\n      subPlan: data.sub_plan, // subscription plan the user subscribed to\r\n      subPlanName: data.sub_plan_name, // subscription plan name the user subscribed to\r\n      isGift: data.is_gift || false, // whether the subscription was a gift subscription\r\n      months: data.months || null, // number of months the subscription was for\r\n      cumulativeMonths: data.cumulative_months || null, // number of cumulative months the user has subscribed for\r\n      streakMonths: data.streak_months || null, // number of months the user has been subscribed for in a row\r\n      subMessage: data.sub_message || null, // subscription message the user sent\r\n      recipientId: data.recipient_id || null, // user id of the user the subscription was gifted to\r\n      recipientUserName: data.recipient_user_name || null, // user name of the user the subscription was gifted to\r\n      recipientDisplayName: data.recipient_display_name || null, // display name of the user the subscription was gifted to\r\n      multiMonthDuration: data.multi_month_duration || null, // number of months the subscription was for\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Whisper event handler\r\n   * @param data The data object\r\n   */\r\n  private __onWhisperEvent(data: any) {\r\n    this.__emit(data.type, data.data);\r\n  }\r\n\r\n  /**\r\n   * Channel points event handler\r\n   * @param data The data object\r\n   */\r\n  private __onChannelPointsEvent({ type, data }: { type: string; data: any }) {\r\n    switch (type) {\r\n      case \"reward-redeemed\":\r\n        this.__emit(\"reward\", data.redemption);\r\n        this.__emit(type, data.redemption);\r\n        break;\r\n      default:\r\n        this.__emit(type, data);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Emit an event\r\n   * @param eventName Event to emit\r\n   * @param args Data to emit\r\n   * @returns This instance\r\n   */\r\n  private __emit(eventName: string, ...args: any[]) {\r\n    eventName = Utils.slug(eventName);\r\n    Emitter.emit(eventName, ...args);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add a listener to an event\r\n   * @param eventName Event to listen to\r\n   * @param callback Callback to call when the event is emitted\r\n   * @returns This instance\r\n   * @example\r\n   * pubsub.on(\"message\", (data) => {\r\n   *  console.log(data);\r\n   * });\r\n   */\r\n  public on(eventName: string, callback: Function) {\r\n    eventName = Utils.slug(eventName);\r\n    if (eventName === \"\") {\r\n      throw new Error(\"Invalid event name\");\r\n    }\r\n    if (typeof callback !== \"function\") {\r\n      throw new Error(\"Invalid callback\");\r\n    }\r\n    Emitter.on(eventName, callback);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove a listener from an event\r\n   * @param eventName Event to remove listener from\r\n   * @param callback Callback to remove\r\n   * @returns This instance\r\n   * @example\r\n   * pubsub.off(\"message\", (data) => {\r\n   *  console.log(data);\r\n   * });\r\n   */\r\n  public off(eventName: string, callback: Function) {\r\n    eventName = Utils.slug(eventName);\r\n    if (eventName === \"\") {\r\n      throw new Error(\"Invalid event name\");\r\n    }\r\n    if (typeof callback !== \"function\") {\r\n      throw new Error(\"Invalid callback\");\r\n    }\r\n    Emitter.removeListener(eventName, callback);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Connect to the pubsub websocket (if not already connected) if autoConnect option is disabled\r\n   * @returns This instance (for chaining) or throws an error if autoConnect is enabled\r\n   * @example\r\n   * pubsub.connect().then(() => {\r\n   *  console.log(\"Connected!\");\r\n   * });\r\n   */\r\n  public connect() {\r\n    if (Options.get().autoConnect) {\r\n      throw new Error(\"autoConnect is enabled\");\r\n    }\r\n    if (PubSub.state() !== \"CONNECTED\") {\r\n      return this.__connect();\r\n    } else {\r\n      return Promise.resolve(this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reconnect to pubsub websocket if autoReconnect option is disabled\r\n   * @returns This instance (for chaining) or throws an error if autoReconnect is enabled\r\n   * @example\r\n   * pubsub.reconnect().then(() => {\r\n   *  console.log(\"Reconnected!\");\r\n   * });\r\n   */\r\n  public reconnect() {\r\n    if (Options.get().autoReconnect) {\r\n      throw new Error(\"autoReconnect is enabled\");\r\n    } else {\r\n      return this.__reconnect();\r\n    }\r\n  }\r\n\r\n  /** Disconnect from the pubsub websocket\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.disconnect().then(() => {\r\n   *  console.log(\"Disconnected!\");\r\n   * });\r\n   */\r\n  public disconnect() {\r\n    return this.__disconnect();\r\n  }\r\n\r\n  /** Get the last latency measurement\r\n   * @returns Latency in milliseconds\r\n   * @example\r\n   * console.log(pubsub.lastLatency());\r\n   * // => 1234\r\n   */\r\n  public lastLatency() {\r\n    return this.__latency;\r\n  }\r\n\r\n  /**\r\n   * Subscribe to a topic or topics (if an array is provided)\r\n   * @param topics Topics to subscribe to\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.subscribe(\"test\").then(() => {\r\n   *  console.log(\"Subscribed!\");\r\n   * });\r\n   */\r\n  public subscribe(topics: string[]) {\r\n    return this.__subscribe(topics);\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from a topic or topics (if an array is provided)\r\n   * @param topics Topics to unsubscribe from (if omitted, all topics are unsubscribed)\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.unsubscribe(\"test\").then(() => {\r\n   *  console.log(\"Unsubscribed!\");\r\n   * });\r\n   */\r\n  public unsubscribe(topics: string[]) {\r\n    return this.__unsubscribe(topics);\r\n  }\r\n\r\n  /**\r\n   * Get all topics registered\r\n   * @returns Array of topics\r\n   */\r\n  public registeredTopics() {\r\n    return Options.get().topics || [];\r\n  }\r\n\r\n  /**\r\n   * Get the number of topics registered\r\n   */\r\n  public registeredTopicsCount() {\r\n    return Options.get().topics.length;\r\n  }\r\n\r\n  /**\r\n   * Check if a topic is registered\r\n   * @param topic Topic to check\r\n   * @returns\r\n   */\r\n  public isRegisteredTopic(topic: string) {\r\n    return Options.get().topics.includes(topic);\r\n  }\r\n\r\n  /**\r\n   * Connection status of the pubsub websocket\r\n   * @returns Connection state (\"CONNECTED\", \"CONNECTING\", \"DISCONNECTING\", \"DISCONNECTED\")\r\n   * @example\r\n   * if (pubsub.state() === \"CONNECTED\") {\r\n   *  console.log(\"Connected!\");\r\n   * }\r\n   */\r\n  public state() {\r\n    return PubSub.state();\r\n  }\r\n}\r\n\r\nwindow.AnotherTwitchPubSub = AnotherTwitchPubSub;\r\n\r\ndeclare global {\r\n  interface Window {\r\n    AnotherTwitchPubSub: typeof AnotherTwitchPubSub;\r\n  }\r\n}\r\n","/**\r\n * Client\r\n */\r\nimport EventEmitter from \"./EventEmitter\";\r\nimport WebSocket from \"./WebSocket\";\r\nexport default class Client extends EventEmitter {\r\n  private client: WebSocket;\r\n  private heartbeatInterval: any;\r\n  private heartbeatIntervalMs: number = 6e4; // 60 seconds\r\n  /**\r\n   * Connect to the websocket\r\n   * @returns A promise with the websocket connection\r\n   */\r\n  public async connect() {\r\n    await new Promise((resolve, reject) => {\r\n      this.client = new WebSocket(\"wss://pubsub-edge.twitch.tv\");\r\n      this.client.onopen = (data: Event) => {\r\n        this.emit(\"connected\", data);\r\n        this.heartbeatInterval = setInterval(\r\n          () => this.heartbeat(),\r\n          this.heartbeatIntervalMs\r\n        );\r\n        resolve(data);\r\n      };\r\n      this.client.onclose = (event: CloseEvent) => {\r\n        const data = {\r\n          code: event.code,\r\n          reason: event.reason,\r\n          message: null,\r\n          wasClean: event.wasClean,\r\n        };\r\n        switch (event.code) {\r\n          case 1000:\r\n            data.message = \"Normal closure\";\r\n            break;\r\n          case 1001:\r\n            data.message = \"Going away\";\r\n            break;\r\n          case 1002:\r\n            data.message = \"Protocol error\";\r\n            break;\r\n          case 1003:\r\n            data.message = \"Unsupported data\";\r\n            break;\r\n          case 1006:\r\n            data.message = \"Abnormal closure\";\r\n            break;\r\n          case 1007:\r\n            data.message = \"Invalid data\";\r\n            break;\r\n          case 1008:\r\n            data.message = \"Policy violation\";\r\n            break;\r\n          case 1009:\r\n            data.message = \"data.Message too big\";\r\n            break;\r\n          case 1010:\r\n            data.message = \"Mandatory extension\";\r\n            break;\r\n          case 1011:\r\n            data.message = \"Internal server error\";\r\n            break;\r\n          default:\r\n            data.message = \"Unknown error\";\r\n            break;\r\n        }\r\n        this.emit(\"disconnected\", data);\r\n        clearInterval(this.heartbeatInterval);\r\n        reject(new Error(data.message));\r\n      };\r\n      this.client.onerror = (error: Event) => {\r\n        this.emit(\"error\", error);\r\n        reject(error);\r\n      };\r\n      this.client.onmessage = (data: MessageEvent) => {\r\n        this.emit(\"raw\", data);\r\n        const message = JSON.parse(data.data);\r\n        switch (message.type) {\r\n          case \"PONG\":\r\n            this.emit(\"pong\", Date.now());\r\n            break;\r\n          case \"MESSAGE\":\r\n            this.emit(\"message\", message);\r\n            break;\r\n          case \"RESPONSE\":\r\n            if (message.error) {\r\n              this.emit(`error:${message.nonce}`, message);\r\n            } else {\r\n              this.emit(`response:${message.nonce}`, message);\r\n            }\r\n            this.emit(\"response\", message);\r\n            break;\r\n          case \"DISCONNECT\":\r\n            this.emit(\"disconnect\", message);\r\n            break;\r\n          case \"RECONNECT\":\r\n            this.emit(\"reconnect\", message);\r\n            break;\r\n          default:\r\n            this.emit(\"unknown\", message);\r\n            break;\r\n        }\r\n      };\r\n    });\r\n    return this.client;\r\n  }\r\n  /**\r\n   * Disconnect from the websocket\r\n   */\r\n  public disconnect() {\r\n    this.client.close();\r\n  }\r\n  /**\r\n   * Send a message to the websocket\r\n   * @param data Data to send to the websocket\r\n   */\r\n  public async send(data: any) {\r\n    this.client.send(JSON.stringify(data));\r\n    if (data.nonce) {\r\n      return await this.waitForResponse(data.nonce);\r\n    }\r\n  }\r\n  /**\r\n   * Wait for a response to a message\r\n   */\r\n  private async waitForResponse(nonce: string) {\r\n    return new Promise((resolve, reject) => {\r\n      this.once(`response:${nonce}`, (response: any) => {\r\n        resolve(response);\r\n      });\r\n      this.once(`error:${nonce}`, (error: any) => {\r\n        reject(error);\r\n      });\r\n      this.once(`timeout:${nonce}`, () => {\r\n        reject(new Error(\"Timeout\"));\r\n      });\r\n\r\n      setTimeout(() => {\r\n        this.emit(`timeout:${nonce}`);\r\n      }, 1000);\r\n    })\r\n      .then((response: any) => {\r\n        this.removeAllListeners(`response:${nonce}`);\r\n        this.removeAllListeners(`error:${nonce}`);\r\n        this.removeAllListeners(`timeout:${nonce}`);\r\n        return response;\r\n      })\r\n      .catch((error: any) => {\r\n        this.removeAllListeners(`response:${nonce}`);\r\n        this.removeAllListeners(`error:${nonce}`);\r\n        this.removeAllListeners(`timeout:${nonce}`);\r\n        throw error;\r\n      });\r\n  }\r\n  /**\r\n   * Heartbeat\r\n   */\r\n  private heartbeat() {\r\n    this.emit(\"ping\", Date.now());\r\n    this.send({\r\n      type: \"PING\",\r\n    });\r\n  }\r\n  /**\r\n   * State of the websocket\r\n   */\r\n  public state() {\r\n    switch (this.client?.readyState) {\r\n      case WebSocket.CONNECTING:\r\n        return \"CONNECTING\";\r\n      case WebSocket.OPEN:\r\n        return \"CONNECTED\";\r\n      case WebSocket.CLOSING:\r\n        return \"DISCONNECTING\";\r\n      case WebSocket.CLOSED:\r\n      default:\r\n        return \"DISCONNECTED\";\r\n    }\r\n  }\r\n}\r\n"],"names":["__webpack_require__","g","globalThis","this","Function","e","window","EventEmitter","events","async","event","data","count","Promise","resolve","Array","isArray","all","map","emit","then","key","hasOwnProperty","forEach","listener","includes","eventName","rest","split","startsWith","toLowerCase","on","callback","push","removeListener","filter","cb","removeAllListeners","once","ws","WebSocket","self","Error","options","accessToken","topics","autoConnect","autoReconnect","reconnectInterval","reconnectAttempts","set","Object","assign","get","setToken","setTopics","findTopic","topic","indexOf","addTopic","removeTopic","index","splice","addTopics","removeTopics","isEmpty","obj","length","keys","arrayLowerCase","arr","item","repeat","fn","times","result","i","nonce","Math","random","toString","substring","join","toCamelCase","str","replace","$1","toUpperCase","slug","sep","RegExp","slugToCamelCase","removeDuplicates","res","fetch","headers","Authorization","Options","json","user","find","name","api","validateToken","client_id","login","user_id","id","err","console","log","isNumber","isNaN","Number","isValidTopic","getTopicsFormat","error","topicName","channelBitsEventsV1","channelBitsEventsV2","channelBitsBadgeUnlocks","channelPointsChannelV1","channelSubscribeEventsV1","chatModeratorActions","automodQueue","userModerationNotifications","whispers","filterTopics","arg1","arg2","topicFormat","getUserId","validade","parseTopic","PubSub","heartbeatIntervalMs","reject","client","onopen","heartbeatInterval","setInterval","heartbeat","onclose","code","reason","message","wasClean","clearInterval","onerror","onmessage","JSON","parse","type","Date","now","disconnect","close","send","stringify","waitForResponse","response","setTimeout","catch","state","readyState","Emitter","AnotherTwitchPubSub","constructor","__latency","__timestamp","__connect","__onConnection","__onDisconnection","__onEventError","__onEventMessage","__onPingSent","__onPongReceived","__onRawMessage","__onResponseMessage","connect","attempts","__reconnect","Utils","parseTopics","auth_token","__send","__emit","__subscribe","eventData","__emitErrorEvent","messageType","messageData","__onChannelPointsEvent","__onBitsEvent","__onSubEvent","__onWhisperEvent","data_object","errorMessage","timestamp","latency","context","userId","userName","user_name","displayName","display_name","channelId","channel_id","channelName","channel_name","time","subPlan","sub_plan","subPlanName","sub_plan_name","isGift","is_gift","months","cumulativeMonths","cumulative_months","streakMonths","streak_months","subMessage","sub_message","recipientId","recipient_id","recipientUserName","recipient_user_name","recipientDisplayName","recipient_display_name","multiMonthDuration","multi_month_duration","redemption","args","off","reconnect","__disconnect","lastLatency","subscribe","unsubscribe","__unsubscribe","registeredTopics","registeredTopicsCount","isRegisteredTopic"],"sourceRoot":""}