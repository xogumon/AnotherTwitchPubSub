{"version":3,"file":"twitch.pubsub.min.js","mappings":"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","sources":["webpack://anothertwitchpubsub/./src/utils/functions.ts","webpack://anothertwitchpubsub/./src/twitch.pubsub.ts"],"sourcesContent":["export default {\r\n  /**\r\n   * Lowercase a array items\r\n   * @param arr Array to lowercase\r\n   * @returns Array with all items lowercased\r\n   * @example\r\n   * const arr = ['THIS', 'IS', 'A', 'TEST'];\r\n   * const lowercased = utils.arrayLowerCase(arr);\r\n   * console.log(lowercased); // ['this', 'is', 'a', 'test']\r\n   */\r\n  arrayLowerCase(arr: any[]) {\r\n    return arr.map((item) => item.toLowerCase());\r\n  },\r\n  /**\r\n   * Repeat a method a number of times\r\n   * @param fn Method to repeat\r\n   * @param times Number of times to repeat\r\n   * @returns Array with the repeated method\r\n   * @example\r\n   * const repeat = utils.repeat(() => 1, 5);\r\n   * console.log(repeat); // [1, 1, 1, 1, 1]\r\n   */\r\n  repeat(fn: Function, times: number) {\r\n    let result = [];\r\n    for (let i = 0; i < times; i++) {\r\n      result.push(fn());\r\n    }\r\n    return result;\r\n  },\r\n  /**\r\n   * Generate a random nonce\r\n   * @returns Random nonce\r\n   */\r\n  nonce() {\r\n    const random = () => Math.random().toString(36).substring(2, 15);\r\n    return this.repeat(random, 2).join(\"\");\r\n  },\r\n  /**\r\n   * Slugify a string\r\n   * @param str String to slugify\r\n   * @param sep Separator to use\r\n   * @returns Slugified string\r\n   * @example\r\n   * const slug = utils.slug(\"This is a string\", \"-\");\r\n   * console.log(slug); // this-is-a-string\r\n   */\r\n  slug(str: string, sep: string = \"-\") {\r\n    if (typeof str !== \"string\") return \"\";\r\n    if (typeof sep !== \"string\") sep = \"-\";\r\n    str = str.toLowerCase().replace(/[^a-z0-9]/g, sep); // replace all non-alphanumeric characters with the separator\r\n    if (sep.length > 0) {\r\n      str = str\r\n        .replace(new RegExp(`${sep}{2,}`, \"g\"), sep) // replace multiple separators with a single one\r\n        .replace(new RegExp(`^${sep}|${sep}$`, \"g\"), \"\"); // remove leading and trailing separators\r\n    }\r\n    return str; // return the slug\r\n  },\r\n  /**\r\n   * Remove duplicate values from an array\r\n   * @param arr Array to remove duplicates from\r\n   * @returns Array with no duplicates\r\n   * @example\r\n   * const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n   * const unique = utils.removeDuplicates(arr);\r\n   * console.log(unique); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n   */\r\n  removeDuplicates(arr: any[]) {\r\n    return arr.filter((item, index) => arr.indexOf(item) === index);\r\n  },\r\n};\r\n","import utils from \"./utils/functions\";\r\n/**\r\n * Interface for options passed to the class constructor.\r\n * @property {string} [channelId] - The id of the channel to subscribe to.\r\n * @property {string} [authToken] - The authentication token to use.\r\n * @property {boolean} [autoConnect] - Whether to automatically connect to the server.\r\n * @property {boolean} [autoReconnect] - Whether to automatically reconnect to the server if the connection is lost.\r\n * @property {number} [reconnectAttempts] - The number of reconnect attempts to make before giving up.\r\n * @property {number} [reconnectInterval] - The time to wait between reconnect attempts.\r\n * @property {string[]} [topics] - The topics to subscribe to.\r\n */\r\ninterface AnotherTwitchPubSubOptions {\r\n  channelId: string;\r\n  authToken: string;\r\n  autoConnect: boolean;\r\n  autoReconnect: boolean;\r\n  reconnectAttempts: number;\r\n  reconnectInterval: number;\r\n  topics: string[];\r\n}\r\n\r\n/**\r\n * @class AnotherTwitchPubSub\r\n * @classdesc AnotherTwitchPubSub is a class that allows you to subscribe to Twitch PubSub topics.\r\n * @param {string} channelId - The channel ID of the channel you want to subscribe to.\r\n * @param {string} authToken - The authentication token of the channel you want to subscribe to.\r\n * @param {boolean} autoConnect - Whether or not to automatically connect to Twitch PubSub.\r\n * @param {boolean} autoReconnect - Whether or not to automatically reconnect to Twitch PubSub if the connection is lost.\r\n * @param {number} reconnectAttempts - The number of reconnect attempts to make before giving up.\r\n * @param {number} reconnectInterval - The time in milliseconds between reconnect attempts.\r\n * @param {string[]} topics - The topics you want to subscribe to.\r\n * @example\r\n * const pubsub = new TwitchPubSub({\r\n *  channelId: 'channelId',\r\n *  authToken: 'authToken',\r\n *  autoConnect: true,\r\n *  autoReconnect: true,\r\n *  reconnectAttempts: 10,\r\n *  reconnectInterval: 1000,\r\n *  topics: ['topic1', 'topic2']\r\n * });\r\n * pubsub.on('message', (topic, message) => {\r\n *  console.log(topic, message);\r\n * });\r\n */\r\nclass AnotherTwitchPubSub {\r\n  constructor(options: AnotherTwitchPubSubOptions) {\r\n    this._options = Object.assign({}, this._options, options);\r\n    this._options.topics = utils.arrayLowerCase(this._options.topics);\r\n    if (\r\n      this._options.channelId === undefined ||\r\n      this._options.authToken === undefined ||\r\n      this._options.topics === undefined ||\r\n      this._options.topics.length === 0 ||\r\n      this._options.topics.length > 50 ||\r\n      this._options.topics.some((topic) => typeof topic !== \"string\")\r\n    ) {\r\n      throw new Error(\"Invalid options\");\r\n    }\r\n    if (this._options.autoConnect) {\r\n      this._connect();\r\n    }\r\n    return this.on(\r\n      \"connected\",\r\n      this._subscribe.bind(this, this._options.topics)\r\n    );\r\n  }\r\n  _client: WebSocket | undefined;\r\n  _events: { [eventName: string]: Array<Function> } = {};\r\n  _options: AnotherTwitchPubSubOptions = {\r\n    // default options\r\n    channelId: \"\", // the channel id to subscribe to\r\n    authToken: \"\", // the authentication token to use\r\n    autoConnect: true, // whether to connect automatically\r\n    autoReconnect: true, // whether to reconnect automatically\r\n    reconnectAttempts: 10, // the number of reconnect attempts\r\n    reconnectInterval: 1000, // the interval between reconnect attempts\r\n    topics: [], // the topics to subscribe to\r\n  };\r\n  _reconnectAttempts: number = 0;\r\n  _pingTimestamp: number = 0;\r\n  _latency: number = 0;\r\n  _heartbeatTimer: ReturnType<typeof setTimeout> | undefined;\r\n  _heartbeatTimeout: number = 6e4;\r\n\r\n  /**\r\n   * Heartbeat function to keep the connection alive and to send a ping to the server\r\n   */\r\n  _heartbeat() {\r\n    if (this.state() === \"open\") {\r\n      this._client?.send(JSON.stringify({ type: \"PING\" }));\r\n      this._pingTimestamp = Date.now();\r\n      this._emit(\"ping\", \"Ping sent\");\r\n      clearTimeout(this._heartbeatTimer);\r\n      this._heartbeatTimer = setTimeout(\r\n        this._heartbeat.bind(this),\r\n        this._heartbeatTimeout\r\n      );\r\n    } else {\r\n      this._latency = 0;\r\n      clearTimeout(this._heartbeatTimer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Connect to the pubsub websocket\r\n   * @returns This instance (for chaining)\r\n   * @private\r\n   * @example\r\n   * pubsub._connect().then(() => {\r\n   *  console.log(\"Connected!\");\r\n   * });\r\n   */\r\n  async _connect() {\r\n    await new Promise((resolve, reject) => {\r\n      if (this.state() === \"closed\") {\r\n        this._client = new WebSocket(\"wss://pubsub-edge.twitch.tv\");\r\n        this._client.onopen = this._clientOpen.bind(this);\r\n        this._client.onclose = this._clientClose.bind(this);\r\n        this._client.onerror = this._clientError.bind(this);\r\n        this._client.onmessage = this._clientMessage.bind(this);\r\n      } else {\r\n        resolve(null);\r\n      }\r\n      this.on(\"connected\", () => {\r\n        resolve(null);\r\n      })\r\n        .on(\"error\", (err: Event) => {\r\n          if (err instanceof Error) reject(err);\r\n        })\r\n        .on(\"disconnected\", (e: CloseEvent) => {\r\n          if (!e.wasClean) reject(e);\r\n        });\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Disconnect from the pubsub websocket\r\n   * @returns This instance (for chaining)\r\n   * @private\r\n   * @example\r\n   * pubsub._disconnect().then(() => {\r\n   *  console.log(\"Disconnected!\");\r\n   * });\r\n   */\r\n  async _disconnect() {\r\n    await new Promise((resolve) => {\r\n      if (this.state() === \"open\") {\r\n        this._client?.close(1000, \"Closed by user\");\r\n      } else if (this.state() === \"closed\") {\r\n        resolve(null);\r\n      }\r\n      this.on(\"disconnected\", () => {\r\n        resolve(null);\r\n      });\r\n    });\r\n    this._client = undefined;\r\n    return this;\r\n  }\r\n\r\n  /** Reconnect to the pubsub websocket\r\n   * @returns This instance (for chaining)\r\n   * @private\r\n   * @example\r\n   * pubsub.reconnect().then(() => {\r\n   *  console.log(\"Reconnected!\");\r\n   * });\r\n   */\r\n  async _reconnect() {\r\n    await new Promise((resolve, reject) => {\r\n      this._disconnect().then(() => {\r\n        this._reconnectAttempts++;\r\n        if (this._reconnectAttempts <= this._options.reconnectAttempts) {\r\n          setTimeout(this._connect.bind(this), this._options.reconnectInterval);\r\n        } else {\r\n          this._reconnectAttempts = 0;\r\n          reject(new Error(\"Reconnect attempts exceeded\"));\r\n        }\r\n      });\r\n      this.on(\"connected\", () => {\r\n        this._reconnectAttempts = 0;\r\n        resolve(null);\r\n      }).on(\"error\", (e: any[]) => {\r\n        reject(e);\r\n      });\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Send a message to the pubsub websocket\r\n   * @param data Data to send\r\n   * @private\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub._send({\r\n   *  type: \"PING\"\r\n   * }).then(() => {\r\n   *  console.log(\"Message sent!\");\r\n   * });\r\n   */\r\n  async _send(data: object) {\r\n    await new Promise((resolve, reject) => {\r\n      if (this.state() === \"open\") {\r\n        resolve(this._client?.send(JSON.stringify(data)));\r\n      } else {\r\n        reject(new Error(\"Not connected\"));\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Subscribe to a topic or topics (if an array is provided)\r\n   * @param topics Topics to subscribe to\r\n   * @private\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub._subscribe(\"test\").then(() => {\r\n   *  console.log(\"Subscribed!\");\r\n   * });\r\n   */\r\n  async _subscribe(topics: string[]) {\r\n    await new Promise((resolve, reject) => {\r\n      if (this.state() !== \"open\") {\r\n        reject(new Error(\"Not connected\"));\r\n      } else {\r\n        if (!Array.isArray(topics)) {\r\n          topics = [topics];\r\n        }\r\n        topics = utils.arrayLowerCase(topics);\r\n        topics = utils.removeDuplicates(topics);\r\n        topics = topics.filter((topic) => this._isValidTopic(topic));\r\n        if (topics.length > 0) {\r\n          this._send({\r\n            type: \"LISTEN\",\r\n            nonce: utils.nonce(),\r\n            data: {\r\n              topics: topics.map(\r\n                (topic) => `${topic}.${this._options.channelId}`\r\n              ),\r\n              auth_token: this._options.authToken,\r\n            },\r\n          })\r\n            .then(() => {\r\n              this._addTopics(topics);\r\n              resolve(null);\r\n            })\r\n            .catch((e) => {\r\n              reject(e);\r\n            });\r\n        } else {\r\n          resolve(null);\r\n        }\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from a topic or topics (if an array is provided)\r\n   * @param topics Topics to unsubscribe from (if omitted, all topics are unsubscribed)\r\n   * @private\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub._unsubscribe(\"test\").then(() => {\r\n   *  console.log(\"Unsubscribed!\");\r\n   * });\r\n   */\r\n  async _unsubscribe(topics: string[]) {\r\n    await new Promise((resolve, reject) => {\r\n      if (this.state() !== \"open\") {\r\n        reject(new Error(\"Not connected\"));\r\n      } else {\r\n        if (!Array.isArray(topics)) {\r\n          topics = [topics];\r\n        }\r\n        topics = utils.arrayLowerCase(topics);\r\n        topics = utils.removeDuplicates(topics);\r\n        topics = topics.filter((topic) => this._isValidTopic(topic));\r\n        topics = (topics || this._options.topics).map(\r\n          (topic) => `${topic}.${this._options.channelId}`\r\n        );\r\n        if (topics.length > 0) {\r\n          this._send({\r\n            type: \"UNLISTEN\",\r\n            nonce: utils.nonce(),\r\n            data: {\r\n              topics,\r\n              auth_token: this._options.authToken,\r\n            },\r\n          })\r\n            .then(() => {\r\n              this._removeTopics(topics);\r\n              resolve(null);\r\n            })\r\n            .catch((e) => {\r\n              reject(e);\r\n            });\r\n        } else {\r\n          resolve(null);\r\n        }\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Open event handler (Client)\r\n   * @private\r\n   */\r\n  _clientOpen() {\r\n    this._emit(\"connected\");\r\n  }\r\n\r\n  /**\r\n   * Close event handler (Client)\r\n   * @param event Event\r\n   * @private\r\n   */\r\n  _clientClose(event: CloseEvent) {\r\n    if (!event.wasClean && this._options.autoReconnect) {\r\n      this._reconnect();\r\n    }\r\n    let message = \"\";\r\n    switch (event.code) {\r\n      case 1000:\r\n        message = \"Normal closure\";\r\n        break;\r\n      case 1001:\r\n        message = \"Going away\";\r\n        break;\r\n      case 1002:\r\n        message = \"Protocol error\";\r\n        break;\r\n      case 1003:\r\n        message = \"Unsupported data\";\r\n        break;\r\n      case 1006:\r\n        message = \"Abnormal closure\";\r\n        break;\r\n      case 1007:\r\n        message = \"Invalid data\";\r\n        break;\r\n      case 1008:\r\n        message = \"Policy violation\";\r\n        break;\r\n      case 1009:\r\n        message = \"Message too big\";\r\n        break;\r\n      case 1010:\r\n        message = \"Mandatory extension\";\r\n        break;\r\n      case 1011:\r\n        message = \"Internal server error\";\r\n        break;\r\n      default:\r\n        message = \"Unknown error\";\r\n        break;\r\n    }\r\n    clearTimeout(this._heartbeatTimer);\r\n    this._emit(\"disconnected\", {\r\n      message,\r\n      reason: event.reason,\r\n      code: event.code,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Message event handler (Client)\r\n   * @param event The event that was received\r\n   * @private\r\n   */\r\n  _clientMessage(event: MessageEvent) {\r\n    const eventData = JSON.parse(event.data);\r\n    const { type, data } = eventData;\r\n    switch (type) {\r\n      case \"PONG\":\r\n        this._onPong();\r\n        break;\r\n      case \"MESSAGE\":\r\n        this._onMessage(eventData);\r\n        break;\r\n      case \"RESPONSE\":\r\n        this._onResponse(eventData);\r\n        break;\r\n      case \"LISTEN\":\r\n      case \"UNLISTEN\":\r\n        this._emit(type, data);\r\n      case \"RECONNECT\":\r\n      case \"DISCONNECT\":\r\n        this._emit(type);\r\n        break;\r\n      default:\r\n        this._onError(new Error(`Unknown message type: ${type}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Error event handler (Client)\r\n   * @param event The event that was received\r\n   * @private\r\n   */\r\n  _clientError(event: ErrorEvent) {\r\n    this._onError(event.error);\r\n  }\r\n\r\n  /**\r\n   * Error event handler\r\n   * @param event The error event\r\n   * @private\r\n   */\r\n  _onError(event: any) {\r\n    if (event instanceof Error) {\r\n      this._emit(\"error\", event.message);\r\n    } else {\r\n      this._emit(\"error\", event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Message event handler\r\n   * @param data The event that was received\r\n   * @private\r\n   */\r\n  _onMessage(data: any) {\r\n    // Emit raw message as message event\r\n    this._emit(\"message\", data);\r\n    // Topic and messages (message is a data object from raw message)\r\n    const { topic, message } = data.data;\r\n    // Emit message event for topic\r\n    this._emit(topic, JSON.parse(message));\r\n    // messageType is the type of topic and messageData is the data of the message\r\n    const { type: messageType, data: messageData } = JSON.parse(message);\r\n    const topicEvents = [\r\n      \"channel-points-channel\",\r\n      \"channel-bits-events\",\r\n      \"channel-bits-badge-unlocks\",\r\n      \"channel-subscribe-events\",\r\n      \"whispers\",\r\n    ];\r\n    // Find the event name for the topic\r\n    const eventName = topicEvents.find((event) => topic.includes(event));\r\n    // Handle events for each topic\r\n    switch (eventName) {\r\n      case \"channel-points-channel\":\r\n        // Channel points events\r\n        this._onChannelPointsEvent({\r\n          type: messageType,\r\n          data: messageData,\r\n        });\r\n        break;\r\n      case \"channel-bits-events\":\r\n      case \"channel-bits-badge-unlocks\":\r\n        // Channel bits events and badge unlocks\r\n        this._onBitsEvent({\r\n          type: eventName,\r\n          data: messageData,\r\n        });\r\n        break;\r\n      case \"channel-subscribe-events\":\r\n        // Channel subscription events\r\n        this._onSubEvent(messageData);\r\n        break;\r\n      case \"whispers\":\r\n        // Whisper events\r\n        this._onWhisperEvent({\r\n          type: messageData.type,\r\n          data: data.data_object,\r\n        });\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Response event handler\r\n   * @param data The response data\r\n   * @private\r\n   */\r\n  _onResponse(data: any) {\r\n    let errorMessage: string;\r\n    if (data?.error) {\r\n      switch (data.error) {\r\n        case \"ERR_BADAUTH\":\r\n          errorMessage = \"Invalid authentication token\";\r\n          break;\r\n        case \"ERR_BADTOPIC\":\r\n          errorMessage = \"Invalid topic\";\r\n          break;\r\n        case \"ERR_BADMESSAGE\":\r\n          errorMessage = \"Invalid message\";\r\n          break;\r\n        case \"ERR_SERVER\":\r\n          errorMessage = \"Server error\";\r\n          break;\r\n        default:\r\n          errorMessage = \"Unknown error\" + data.error;\r\n          break;\r\n      }\r\n      this._onError(errorMessage);\r\n    } else {\r\n      if (data) this._emit(\"response\", data);\r\n      this._heartbeat(); // start the heartbeat\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pong event handler\r\n   * @private\r\n   */\r\n  _onPong() {\r\n    clearTimeout(this._heartbeatTimer);\r\n    this._heartbeatTimer = setTimeout(\r\n      this._heartbeat.bind(this),\r\n      this._heartbeatTimeout\r\n    );\r\n    this._latency = Date.now() - this._pingTimestamp;\r\n    this._emit(\"pong\", this._latency);\r\n    if (this._latency > 1e4) {\r\n      if (this._options.autoReconnect) {\r\n        this._reconnect();\r\n      } else {\r\n        // if latency is greater than 10 seconds\r\n        this._emit(\"warning\", {\r\n          message: \"Latency is very high\",\r\n          latency: this._latency,\r\n        });\r\n      }\r\n    } else if (this._latency > 1e3) {\r\n      // if latency is greater than 1 second\r\n      this._emit(\"warning\", {\r\n        message: \"Latency is high\",\r\n        latency: this._latency,\r\n      });\r\n    } else if (this._latency > 1e2) {\r\n      // if latency is greater than 100 milliseconds\r\n      this._emit(\"warning\", {\r\n        message: \"Latency is medium\",\r\n        latency: this._latency,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bits event handler\r\n   * @param data The data object\r\n   * @private\r\n   */\r\n  _onBitsEvent({ type, data }: { type: string; data: any }) {\r\n    switch (type) {\r\n      case \"channel-bits-events\":\r\n        this._emit(\"bits\", data);\r\n        break;\r\n      case \"channel-bits-badge-unlocks\":\r\n        this._emit(\"bitsbadge\", data);\r\n        break;\r\n      default:\r\n        this._onError(new Error(`Unknown message type: ${type}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscription event handler\r\n   * (sub, resub, subgift, anonsubgift)\r\n   * @param data The data object\r\n   * @private\r\n   */\r\n  _onSubEvent(data: any) {\r\n    this._emit(data.context, {\r\n      userId: data.user_id || null, // user id of the user who subscribed\r\n      userName: data.user_name || null, // user name of the user who subscribed\r\n      displayName: data.display_name || null, // display name of the user who subscribed\r\n      channelId: data.channel_id, // channel id of the channel the subscription was made in\r\n      channelName: data.channel_name, // channel name of the channel the subscription was made in\r\n      time: data.time, // time the subscription was made\r\n      subPlan: data.sub_plan, // subscription plan the user subscribed to\r\n      subPlanName: data.sub_plan_name, // subscription plan name the user subscribed to\r\n      isGift: data.is_gift || false, // whether the subscription was a gift subscription\r\n      months: data.months || null, // number of months the subscription was for\r\n      cumulativeMonths: data.cumulative_months || null, // number of cumulative months the user has subscribed for\r\n      streakMonths: data.streak_months || null, // number of months the user has been subscribed for in a row\r\n      subMessage: data.sub_message || null, // subscription message the user sent\r\n      recipientId: data.recipient_id || null, // user id of the user the subscription was gifted to\r\n      recipientUserName: data.recipient_user_name || null, // user name of the user the subscription was gifted to\r\n      recipientDisplayName: data.recipient_display_name || null, // display name of the user the subscription was gifted to\r\n      multiMonthDuration: data.multi_month_duration || null, // number of months the subscription was for\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Whisper event handler\r\n   * @param data The data object\r\n   * @private\r\n   */\r\n  _onWhisperEvent(data: any) {\r\n    this._emit(data.type, data.data);\r\n  }\r\n\r\n  /**\r\n   * Channel points event handler\r\n   * @param data The data object\r\n   * @private\r\n   */\r\n  _onChannelPointsEvent({ type, data }: { type: string; data: any }) {\r\n    switch (type) {\r\n      case \"reward-redeemed\":\r\n        this._emit(\"reward\", data.redemption);\r\n        this._emit(type, data.redemption);\r\n        break;\r\n      default:\r\n        this._emit(type, data);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /** Add topics to the topics array\r\n   * @param topics Topics to add\r\n   * @private\r\n   * @example\r\n   * pubsub._addTopics([\"topic1\", \"topic2\"]);\r\n   * pubsub._addTopics([\"topic3\", \"topic4\"]);\r\n   * console.log(pubsub.registeredTopics()); // [\"topic1\", \"topic2\", \"topic3\", \"topic4\"]\r\n   */\r\n  _addTopics(topics: string[]) {\r\n    if (!Array.isArray(topics)) {\r\n      topics = [topics];\r\n    }\r\n    topics.forEach((topic) => {\r\n      if (!this._options.topics.includes(topic))\r\n        this._options.topics.push(topic);\r\n    });\r\n    return this._options.topics;\r\n  }\r\n\r\n  /** Remove topics from the list of topics to listen to\r\n   * @param topics Topics to remove\r\n   * @private\r\n   * @example\r\n   * pubsub._addTopics([\"topic1\", \"topic2\", \"topic3\", \"topic4\"]);\r\n   * pubsub._removeTopics([\"topic2\", \"topic3\"]);\r\n   * console.log(pubsub.registeredTopics()); // [\"topic1\", \"topic4\"]\r\n   */\r\n  _removeTopics(topics: string[]) {\r\n    if (!Array.isArray(topics)) {\r\n      topics = [topics];\r\n    }\r\n    this._options.topics = this._options.topics.filter(\r\n      (topic) => !topics.includes(topic)\r\n    );\r\n    return this._options.topics;\r\n  }\r\n\r\n  /**\r\n   * Check if an topic is valid\r\n   * @param topic Topic to check\r\n   * @private\r\n   * @returns True if topic is valid, false otherwise\r\n   * @example\r\n   * console.log(pubsub._isValidTopic('channel-bits-events-v2')); // true\r\n   * console.log(pubsub._isValidTopic('channel-bits-events-v3')); // false\r\n   */\r\n  _isValidTopic(topic: string) {\r\n    try {\r\n      const availableTopics = [\r\n        \"channel-bits-events-v1\",\r\n        \"channel-bits-events-v2\",\r\n        \"channel-bits-badge-unlocks\",\r\n        \"channel-points-channel-v1\",\r\n        \"channel-subscribe-events-v1\",\r\n        \"chat-moderator-actions\",\r\n        \"automod-queue\",\r\n        \"user-moderation-notifications\",\r\n        \"whispers\",\r\n      ];\r\n      if (typeof topic !== \"string\") {\r\n        throw new Error(\"Invalid topic\");\r\n      }\r\n      if (topic.length > 100) {\r\n        throw new Error(\"Topic is too long\");\r\n      }\r\n      return availableTopics.some((availableTopic) =>\r\n        topic.toLowerCase().includes(availableTopic)\r\n      );\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Emit an event\r\n   * @param eventName Event to emit\r\n   * @param args Data to emit\r\n   * @private\r\n   * @returns This instance\r\n   */\r\n  _emit(eventName: string, ...args: any[]) {\r\n    eventName = utils.slug(eventName);\r\n    if (this._events.hasOwnProperty(eventName)) {\r\n      this._events[eventName].forEach((callback: Function) => {\r\n        callback(...args);\r\n      });\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add a listener to an event\r\n   * @param eventName Event to listen to\r\n   * @param callback Callback to call when the event is emitted\r\n   * @returns This instance\r\n   * @example\r\n   * pubsub.on(\"message\", (data) => {\r\n   *  console.log(data);\r\n   * });\r\n   */\r\n  on(eventName: string, callback: Function) {\r\n    eventName = utils.slug(eventName);\r\n    if (eventName === \"\") {\r\n      throw new Error(\"Invalid event name\");\r\n    }\r\n    if (typeof callback !== \"function\") {\r\n      throw new Error(\"Invalid callback\");\r\n    }\r\n    if (!this._events.hasOwnProperty(eventName)) {\r\n      this._events[eventName] = [];\r\n    }\r\n    this._events[eventName].push(callback);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove a listener from an event\r\n   * @param eventName Event to remove listener from\r\n   * @param callback Callback to remove\r\n   * @returns This instance or false if the callback was not found\r\n   * @example\r\n   * pubsub.off(\"message\", (data) => {\r\n   *  console.log(data);\r\n   * });\r\n   */\r\n  off(eventName: string, callback: Function) {\r\n    eventName = utils.slug(eventName);\r\n    if (eventName === \"\") {\r\n      throw new Error(\"Invalid event name\");\r\n    }\r\n    if (typeof callback !== \"function\") {\r\n      throw new Error(\"Invalid callback\");\r\n    }\r\n    if (this._events.hasOwnProperty(eventName)) {\r\n      const index = this._events[eventName].indexOf(callback);\r\n      if (index > -1) {\r\n        this._events[eventName].splice(index, 1);\r\n        return this;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Connect to the pubsub websocket (if not already connected) if autoConnect option is disabled\r\n   * @returns This instance (for chaining) or throws an error if autoConnect is enabled\r\n   * @example\r\n   * pubsub.connect().then(() => {\r\n   *  console.log(\"Connected!\");\r\n   * });\r\n   */\r\n  connect() {\r\n    if (this._options.autoConnect) {\r\n      throw new Error(\"autoConnect is enabled\");\r\n    }\r\n    if (this.state() !== \"open\") {\r\n      return this._connect();\r\n    } else {\r\n      return Promise.resolve(this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reconnect to pubsub websocket if autoReconnect option is disabled\r\n   * @returns This instance (for chaining) or throws an error if autoReconnect is enabled\r\n   * @example\r\n   * pubsub.reconnect().then(() => {\r\n   *  console.log(\"Reconnected!\");\r\n   * });\r\n   */\r\n  reconnect() {\r\n    if (this._options.autoReconnect) {\r\n      throw new Error(\"autoReconnect is enabled\");\r\n    } else {\r\n      return this._reconnect();\r\n    }\r\n  }\r\n\r\n  /** Disconnect from the pubsub websocket\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.disconnect().then(() => {\r\n   *  console.log(\"Disconnected!\");\r\n   * });\r\n   */\r\n  disconnect() {\r\n    return this._disconnect();\r\n  }\r\n\r\n  /** Get the last latency measurement\r\n   * @returns Latency in milliseconds\r\n   * @example\r\n   * console.log(pubsub.lastLatency());\r\n   * // => 1234\r\n   */\r\n  lastLatency() {\r\n    return this._latency;\r\n  }\r\n\r\n  /**\r\n   * Subscribe to a topic or topics (if an array is provided)\r\n   * @param topics Topics to subscribe to\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.subscribe(\"test\").then(() => {\r\n   *  console.log(\"Subscribed!\");\r\n   * });\r\n   */\r\n  subscribe(topics: string[]) {\r\n    return this._subscribe(topics);\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from a topic or topics (if an array is provided)\r\n   * @param topics Topics to unsubscribe from (if omitted, all topics are unsubscribed)\r\n   * @returns This instance (for chaining)\r\n   * @example\r\n   * pubsub.unsubscribe(\"test\").then(() => {\r\n   *  console.log(\"Unsubscribed!\");\r\n   * });\r\n   */\r\n  unsubscribe(topics: string[]) {\r\n    return this._unsubscribe(topics);\r\n  }\r\n\r\n  /**\r\n   * Get all topics registered\r\n   * @returns Array of topics\r\n   */\r\n  registeredTopics() {\r\n    return this._options.topics || [];\r\n  }\r\n\r\n  /**\r\n   * Get the number of topics registered\r\n   */\r\n  registeredTopicsCount() {\r\n    return this.registeredTopics().length;\r\n  }\r\n\r\n  /**\r\n   * Check if a topic is registered\r\n   * @param topic Topic to check\r\n   * @returns\r\n   */\r\n  isRegisteredTopic(topic: string) {\r\n    return this.registeredTopics().includes(topic);\r\n  }\r\n\r\n  /**\r\n   * Connection status of the pubsub websocket\r\n   * @returns Connection state (open, closed, connecting, or disconnected)\r\n   * @example\r\n   * if (pubsub.state() === \"open\") {\r\n   *  console.log(\"Connected!\");\r\n   * }\r\n   */\r\n  state() {\r\n    const { readyState } = this._client || {};\r\n    switch (readyState) {\r\n      case WebSocket.CONNECTING:\r\n        return \"connecting\";\r\n      case WebSocket.OPEN:\r\n        return \"open\";\r\n      case WebSocket.CLOSING:\r\n        return \"closing\";\r\n      case WebSocket.CLOSED:\r\n      default:\r\n        return \"closed\";\r\n    }\r\n  }\r\n}\r\n\r\ndeclare global {\r\n  interface Window {\r\n    AnotherTwitchPubSub: typeof AnotherTwitchPubSub;\r\n  }\r\n}\r\n\r\nwindow.AnotherTwitchPubSub = AnotherTwitchPubSub;\r\n"],"names":["arrayLowerCase","arr","map","item","toLowerCase","repeat","fn","times","result","i","push","nonce","this","Math","random","toString","substring","join","slug","str","sep","replace","length","RegExp","removeDuplicates","filter","index","indexOf","window","AnotherTwitchPubSub","constructor","options","_events","_options","channelId","authToken","autoConnect","autoReconnect","reconnectAttempts","reconnectInterval","topics","_reconnectAttempts","_pingTimestamp","_latency","_heartbeatTimeout","Object","assign","undefined","some","topic","Error","_connect","on","_subscribe","bind","_heartbeat","state","_client","send","JSON","stringify","type","Date","now","_emit","clearTimeout","_heartbeatTimer","setTimeout","Promise","resolve","reject","WebSocket","onopen","_clientOpen","onclose","_clientClose","onerror","_clientError","onmessage","_clientMessage","err","e","wasClean","_disconnect","close","_reconnect","then","_send","data","Array","isArray","_isValidTopic","auth_token","_addTopics","catch","_unsubscribe","_removeTopics","event","message","code","reason","eventData","parse","_onPong","_onMessage","_onResponse","_onError","error","messageType","messageData","eventName","find","includes","_onChannelPointsEvent","_onBitsEvent","_onSubEvent","_onWhisperEvent","data_object","errorMessage","latency","context","userId","user_id","userName","user_name","displayName","display_name","channel_id","channelName","channel_name","time","subPlan","sub_plan","subPlanName","sub_plan_name","isGift","is_gift","months","cumulativeMonths","cumulative_months","streakMonths","streak_months","subMessage","sub_message","recipientId","recipient_id","recipientUserName","recipient_user_name","recipientDisplayName","recipient_display_name","multiMonthDuration","multi_month_duration","redemption","forEach","availableTopics","availableTopic","args","hasOwnProperty","callback","off","splice","connect","reconnect","disconnect","lastLatency","subscribe","unsubscribe","registeredTopics","registeredTopicsCount","isRegisteredTopic","readyState","CONNECTING","OPEN","CLOSING","CLOSED"],"sourceRoot":""}